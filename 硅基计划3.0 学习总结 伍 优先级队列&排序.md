# 硅基计划3.0 学习总结 伍 优先级队列&排序

***

![图 (463)](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202507311022686.png)

***

[toc]

***

## 一、优先级队列  
这个队列说白了也就是一维数组，但是呢内部数据是具有优先性的，可以以一个关键字或者是数字为标准进行增删查改，比如我要求最小的几个数或者是最大的几个数等等  
而这个优先级队列的底层使用到了**堆**，而**堆**就类似于我们之前讲过的完全二叉树  

而我们的优先级队列因此就储存在我们的一维数组中了，因此我们根据内部数据排序分为了**大根堆**和**小根堆**  

### 1. 大根堆&小根堆  
对于左右孩子节点，大的在右边还是左边并无明确规定  

* 大根堆：堆顶元素大于左右孩子节点值  
* 小根堆：堆顶元素小于左右孩子节点值  

![image-20250801110524259](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508011105332.png)

### 2. 创建堆  
我们先拿到一个数组，然后根据数组下标把对应的数字放在对应位置  
![image-20250801113543531](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508011135623.png)

**向下调整**指的就是每次调整的时候从每棵子树的根节点开始向下面调整的  
因此我们只需要知道每棵子树的根节点就好了  
说白了就是每次调整的时候，以每一棵子树的根节点开始，往最下面的地方开始调  
比如刚刚的图，如果我以65为此时的根节点，那我就要调整到25，如果我以49为此时的根节点，我还是要调整到25，为什么，你看  
![image-20250801114021680](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508011140746.png)
因此虽然当前子树是大根堆，但是你能保证当前子树的左右子树的子树是大根堆吗，不能保证  

好，那我们怎么根据孩子节点求根节点呢，还记得我们之前的公式`(i-1)/2`吗，因此我们就可以先求数组长度，然后-1让其和数组最后一个下标重合，再带入公式，此时我们调整就是从最后一个节点的父节点开始调整了，然后循环往前走就好了  
好，我们也把创建小根堆方法补充上  

```java
public class TestHeap {
    public int [] arrays;
    public int usedSize;

    public TestHeap() {
        arrays = new int[15];
    }

    //此时我们开始构造数据
    public void intArray(int [] array){
        for (int i = 0; i < array.length; i++) {
            arrays[i] = array[i];
        }
        usedSize = array.length;
    }

    //开始创建大根堆
    public void createHeap(){
        for(int parent = (usedSize-1-1)/2;parent>=0;parent--){
            //每棵子树都要被调整，父节点往前走，直到走到根节点
            //每次调整都是从当前的父节点开始往最后一个节点调整
            siftDown(parent,usedSize);
        }
    }

    //开始创建小根堆
    public void createHeaps(){
        for(int parent = (usedSize-1-1)/2;parent>=0;parent--){
            //每棵子树都要被调整，父节点往前走，直到走到根节点
            //每次调整都是从当前的父节点开始往最后一个节点调整
            upDown(parent,usedSize);
        }
    }

    //parent就是每次每次调整开始的父节点，usedSize就是每次调整的时候的终止节点
    private void siftDown(int parent, int usedSize) {
        int child = 2*parent+1;
        //此时我们要保证子节点在合法范围内
        //限定条件，要保证有右孩子，如果没有就不能++
        while(child < usedSize){
            if(arrays[child] < arrays[child+1] && child+1 < usedSize){
                child++;//如果做孩子不是最大值，那再去检查右孩子看看
            }
            //此时child是最大孩子的下标
            //但是你要考虑特殊情况
            //如果当前子树就一个左孩子呢，右孩子++的话不就越界了吗

            //条件加上后此时左孩子就是两个孩子节点的最大值
            //判断然后去看是否要交换
            if(arrays[child] > arrays[parent]){
                int temp = arrays[child];
                arrays[child] = arrays[parent];
                arrays[parent] = temp;
                //此时再去检查左右子树的子树是不是都是大根堆
                parent = child;
                child = 2*parent+1;
            }else{
                //如果本身就是大根堆，那就什么都不干，直接break
                break;
                //如果你好奇为什么下面的不用去判断，因为我们是向下调整
                //我们每次调整都是从最下面一棵树开始向上走，下面的子树已经是大根堆了
                //那我们当前的树也就是大根堆
            }
        }
    }

    //我们尝试再写个小根堆
    private void upDown(int parent, int usedSize) {
        int child = 2*parent+1;
        while(child < usedSize){
            if(arrays[child] > arrays[child+1] && child+1 < usedSize){
                child++;
            }
            if(arrays[child] < arrays[parent]){
                int temp = arrays[child];
                arrays[child] = arrays[parent];
                arrays[parent] = temp;
                parent = child;
                child = 2*parent+1;
            }else{
                //如果本身就是大根堆，那就什么都不干，直接break
                break;
                //如果你好奇为什么下面的不用去判断，因为我们是向下调整
                //我们每次调整都是从最下面一棵树开始向上走，下面的子树已经是大根堆了
                //那我们当前的树也就是大根堆
            }
        }
    }
}
```
好，我们来分析时间复杂度  
如果你树的高度是`h`，第一层节点数为$2^0$个，第二次是$2^1$个......第h-1层是`2^(h-2)`个，（最后一层不用比较）  
好，我们再分析每一层要调整的树的高度是多少，第一层调整除了根节点以外的层数，为`h-1`层，第二次是`h-2`层......第h-1层是`1`层  
那我们根据时间复杂度定义，每一层有这么多节点，然后每一层的节点调整次数也不用，因此  
$$
2^0(h-1)+2^1(h-2)+......+2^{h-2}
$$
我们进行求和，最后是$2^{h-1}-h-1$  
又因为节点的个数是$n=2^h-1$推导出$h=/log(n+1)$，带入公式求得$nlog(n+1)$，在n趋于无穷的时候可以忽略  
因此最后时间复杂度就是O(n)  

### 3. 堆的创建&删除  
我们每次增删查改的时候，一定要保证再增删查改后的堆还是大根堆  

我们先来讲出插入堆，插入我们要插入到最后一个节点后面  
我们之前讲过，堆就是数组，那数组满了是不是需要扩容呢，当你插入之后要看看当前的堆是不是大根堆/小根堆，如果不是要调整  
插入的时候不需要比较你的另一个兄弟节点，因为我们说过大根堆和小根堆都没有明确规定左右孩子节点谁要大一点谁要小一点  
插入的时候，就是向上调整了  
向上调整与向下调整类似，虽然你当前的树是大根堆或者是小根堆了，但是你能保证比这更大一级的树是大根堆或者是小根堆吗，并不能，因此要继续向上调整，一直调整到子节点是0的时候或者是你的父节点是根节点的根节点（空）的时候就调完了  
![image-20250801132303574](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508011323657.png)
```java
//插入节点
    public void offer(int val){
        if(isFull()){
            //满了就扩容
            arrays = Arrays.copyOf(arrays,arrays.length*2);
        }
        arrays[usedSize] = val;
        siftUp(usedSize);
        usedSize++;
    }

    //向上调整2.0版
    private void siftUp(int child){
        int parent = (child-1)/2;
        while(parent >= 0){
            if(arrays[child] > arrays[parent]){
                int temp = arrays[child];
                arrays[child] = arrays[parent];
                arrays[parent] = temp;
                child = parent;
                parent = (child-1)/2;
            }else{
                break;
            }
        }
    }

    private boolean isFull(){
        return usedSize == arrays.length;
    }
```

好，我们再来讲删除，好，假设现在有个堆已经是大根堆了，那我们删除完后因为要保持大根堆，因此我们可以采用删除堆顶元素方法  
具体就是**让最后一个元素和堆顶元素进行交换，再让`usedSize`减减，从而达到删除目的**  
此时我们仅仅只需要调整根节点所在的这棵树就好了，大大缩小了复杂度，自然就是向下调整  
我们再把查看堆顶元素也实现下  
```java
public int poll(){
        if(isEmpty()){
            return -1;
        }
        //否则我们就进行交换
        int value = arrays[usedSize-1];
        int temp = arrays[0];
        arrays[0] = arrays[usedSize-1];
        arrays[usedSize-1] = arrays[0];
        usedSize--;
        //从根节点开始调整到最后一个节点的位置
        siftDown(0,usedSize);
        return value;
    }

    private boolean isEmpty(){
        return usedSize == 0;
    }

    public void display(){
        for(int i = 0;i<usedSize;i++){
            System.out.print(arrays[i]+" ");
        }
        System.out.println();
    }

    public int peek(){
        return arrays[0];
    }
```

### 4. 堆的应用——堆排序  
如果要你从小到大排序，你是建大根堆还是小根堆呢？答案是大根堆，为什么？  

你看嘛，大根堆它的堆顶元素一定是整棵树最大的元素，因此我们让堆顶元素和最后一个元素进行交换  
![image-20250801141129297](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508011411435.png)
```java
//排序，从小到大
    public void heapSort(){
        int end = usedSize-1;
        while(end > 0){
            int temp = arrays[0];
            arrays[0] = arrays[end];
            arrays[end] = temp;
            siftDown(0,end);
            end--;
        }
    }

    //排序，从大到小
    public void heapSorts(){
        createHeaps(); //使用小根堆构建方法
        int end = usedSize - 1;
        while (end > 0) {
            int temp = arrays[0];
            arrays[0] = arrays[end];
            arrays[end] = temp;
            upDown(0, end); //使用小根堆调整方法
            end--;
        }
    }
```

### 5. 堆的应用——TopK问题  
这个问题就是给一组非常大的数据，让你求前几个最值  
我们就举个例子吧  
![image-20250801150816692](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508011508824.png)
有了这种思想，我们的时间复杂度就大大降低了  
时间复杂度是$klogk+(n-k)logk$，化简成$nlogk$，但是我们一般k即求前k最值的k一般很小，一次你最后化简成O(n)  
而且此时堆顶元素就是我们要修的第k小或者是大的元素，amazing！  

## 二、 PriorityQueue类  
这个是Java官方提供的优先级队列的类，它的创建格式是  
```java
public static void main(String[] args) {
        PriorityQueue <Integer> priorityQueue = new PriorityQueue<>();
        priorityQueue.offer(11);
        priorityQueue.offer(44);
        priorityQueue.offer(66);
        System.out.println(priorityQueue);
    }
```
我们可以知道打印的结果小根堆，说明了创建`PriorityQueue`类时，默认就是按照小根堆存放的  

1. 如果你`offer`的几个数据不能够比较大小，比如对象之类的，那它就会抛出类型转换异常  
![image-20250801152056831](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508011520348.png)
那怎么办呢，很简单，我们让`Person`类实现`Comparable`接口就好了，重写`comparTo`方法  
![image-20250801152803757](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508011528207.png)

2. 不可以插入空对象null，否则会抛出异常  
3. 插入与删除的时间复杂度都是$logn$  

### 1. 构造方法

要想了解一个类，首先就是要先了解它的构造方法  
你打开会发现有几个老熟人，`DEFAULT_INITIAL_CAPACITY`默认大小，`Object [] queue`队列，`size`的有效个数表示等等  
`private final Comparator<? super E> comparator;`，这个比较起我们还未初始化，因此此时是null  

我们来看第一个构造方法，它是不带参的构造方法  
```java
public PriorityQueue() {
        this(DEFAULT_INITIAL_CAPACITY, null);
    }
```
我们可以看到其内部又调用了带两个参数的构造方法，后面那个null就是我们刚刚的比较器  

接着看第二个构造方法  
```java
public PriorityQueue(int initialCapacity) {
        this(initialCapacity, null);
    }
```
这个就是指定容量大小，也就是说我们在传参时候可以指定这个优先级队列数组的大小，比较器默认还是null的  

我们在看第三个构造方法  
```java
public PriorityQueue(int initialCapacity,
                         Comparator<? super E> comparator) {
        // Note: This restriction of at least one is not actually needed,
        // but continues for 1.5 compatibility
        if (initialCapacity < 1)
            throw new IllegalArgumentException();
        this.queue = new Object[initialCapacity];
        this.comparator = comparator;
    }
```
我们刚刚两个构造方法就是调用了这个构造方法，我们只能指定数组大小，并不能指定比较器  

我们再看下一个构造方法，是一个比较器的构造方法  
```java
public PriorityQueue(Comparator<? super E> comparator) {
        this(DEFAULT_INITIAL_CAPACITY, comparator);
    }
```
还有其他构造方法，就不一样叙述了

### 2. 插入元素——offer方法  
```java
public boolean offer(E e) {
        if (e == null)
            throw new NullPointerException();
        modCount++;
        int i = size;
        if (i >= queue.length)
            grow(i + 1);
        siftUp(i, e);
        size = i + 1;
        return true;
    }
```
我们点开`siftUp`方法  
```java
private void siftUp(int k, E x) {
        if (comparator != null)
            siftUpUsingComparator(k, x, queue, comparator);
        else
            siftUpComparable(k, x, queue);
    }
```
可以看到当我们比较器是null时候调用了`siftUpUsingComparator(k, x, queue, comparator);`方法  
```java
private static <T> void siftUpUsingComparator(
        int k, T x, Object[] es, Comparator<? super T> cmp) {
        while (k > 0) {
            int parent = (k - 1) >>> 1;
            Object e = es[parent];
            if (cmp.compare(x, (T) e) >= 0)
                break;
            es[k] = e;
            k = parent;
        }
        es[k] = x;
    }
```
你会发现这个和我们写的小根堆的方法非常类似，`>>>1`指的是除以2的意思  
但是这也就说明了源码是默认小根堆的，那我如果想去实现大根堆怎么搞呢，总不能去修改源码吧  
因此我们就要自己去重写`compareTo`方法，我们之前已经写过了，我们直接拿过来  
```java
public class Person implements Comparable<Person>{
    public int high;

    public Person(int high) {
        this.high = high;
    }

    @Override
    public int compareTo(Person o) {
        return o.high - this.high;
    }
}

public static void main(String[] args) {
        Person person1 = new Person(180);
        Person person2 = new Person(175);
        Person person3 = new Person(170);
        PriorityQueue <Person> priorityQueue1 = new PriorityQueue<>();
        priorityQueue1.offer(person1);
        priorityQueue1.offer(person2);
        priorityQueue1.offer(person3);
        System.out.println("按升序排列（最大堆）:");
        while (!priorityQueue1.isEmpty()) {
            System.out.print(priorityQueue1.poll().high+" ");
        }
    }
```

### 3. 传比较器  
我们刚刚看到构造方法可以传入自己的比较器，那我们就自己写一个比较器  
```java
public class MaxComparator implements Comparator<Integer> {
    @Override
    public int compare(Integer o1,Integer o2) {
        return o2.compareTo(o1);//o2-o1
        //return o1.compareTo(o2);//o1-o2
    }
}

public static void main(String[] args) {
        MaxComparator maxComparator = new MaxComparator();
        PriorityQueue <Integer> priorityQueue1 = new PriorityQueue<>(maxComparator);
        priorityQueue1.offer(11);
        priorityQueue1.offer(15);
        priorityQueue1.offer(18);
        while (!priorityQueue1.isEmpty()) {
            System.out.print(priorityQueue1.poll()+" ");
        }
    }
```
因此此时的构造方法调用的就是有比较器的`siftUpComparable`方法了  

### 4. 扩容方法grow  
我们可以去看源码  
```java
private void grow(int minCapacity) {
        int oldCapacity = queue.length;
        // Double size if small; else grow by 50%
        int newCapacity = ArraysSupport.newLength(oldCapacity,
                minCapacity - oldCapacity, /* minimum growth */
                oldCapacity < 64 ? oldCapacity + 2 : oldCapacity >> 1
                                           /* preferred growth */);
        queue = Arrays.copyOf(queue, newCapacity);
    }
```
我们可以看到如果小于64容量，我们就二倍扩容，否则就是1.5倍扩容  
但是如果容量超过了整型最大值减去8这个容量时，就以`MAX_ARRAY_SIZE`进行扩容  

### 5. 完善TopK问题  
还记得我们上节课遗留的TopK问题吗，我们就可以用这个传比较器的思想去完成  
这里给出题目[题目链接](https://leetcode.cn/problems/smallest-k-lcci/)  
```java
class Solution {
    public int[] smallestK(int[] array, int k) {
        int [] ret = new int[k];
        if(array == null || k <= 0){
            //验证合法性
            return ret;
        }
        
        //传入比较器
        MaxComparator maxComparator = new MaxComparator();
        
        //建立优先级队列
        PriorityQueue <Integer> priorityQueue = new PriorityQueue<>(maxComparator);

        //把前K个建成大根堆
        for(int i = 0;i < k;i++){
            priorityQueue.offer(array[i]);
        }

        //遍历剩下N-K个元素
        for(int i = k;i<array.length;i++){
            //查看堆顶元素
            int peekValue = priorityQueue.peek();
            if(peekValue > array[i]){
                //说明堆顶元素不是最小的前K个数
                priorityQueue.poll();
                //把比原先堆顶元素更小的数放进去
                priorityQueue.offer(array[i]);
            }
        }
        
        //把结果放进数组内
        for(int i = 0;i < k;i++){
            ret[i] = priorityQueue.poll();
        }
        return ret;
    }
}

public class MaxComparator implements Comparator<Integer> {
    @Override
    public int compare(Integer o1,Integer o2) {
        return o2.compareTo(o1);//o2-o1
        //return o1.compareTo(o2);//o1-o2
    }
}
```

## 三、 排序——hard  
排序它的核心思想就是我们对一个新的值插入到已经排列好的序列中去  

我们先来讲什么是稳定和不稳定   
![image-20250802091627975](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508020916091.png)

* 内部排序：内存中排序  
* 外部排序：不在内存中排序，但是和内部排序紧密联系，交换数据

### 1. 插入排序  
顾名思义就是插入数字后进行排序，且看我图解  
![image-20250802082346409](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508020823561.png)

好，那么如何去比较数字呢，很简单，我们定义一个中间变量tmp，每次把`i`下标的数字放入中间变量`tmp`中，然后让`j`下标数字和`tmp`去比，如果比`i`下标的数字小，说明此时`j`下标和`i`下标时间是从小到大的顺序，符合要求  
如果`j`下标数字比`i`下标大，那就要把下标`j`位置的数字放在`j+1`，为什么不是放在`i`下标呢  
![image-20250802085444289](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508020854432.png)
好，你问为什么我们不把值放在`i`下标位置，这会导致排序错误，请看演示  
![image-20250802085841089](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508020858218.png)
那好，我们来完善代码吧  

```java
//直接插入排序
    public void insertSort(int [] array){
        for(int i = 1;i < nums.length;i++){
            int j = i-1;
            int tmp = nums[i];
            while (j >= 0 && nums[j] > tmp) {
                nums[j + 1] = nums[j];
                j--;
            }
            nums[j+1] = tmp;
        }
    }
```
我们来分析时间复杂度，最坏的情况我们就是要把全部是从大到小的数据排列成从小到大的数据，每次排序排比当前下标所在位置少一个的元素（刚刚演示过）  
是一个等差数列，我们求和结果是$\sum n^2$，因此时间复杂度就是O($n^2$)  
空间复杂度就是O(1)，因为没有申请额外空间  

我们重点来分析稳定性方面  
我们的交换条件是`array[j]>tmp`，因此如果数字相同，并不会产生交换，从而保持了稳定  
比如`2(红) 5 2`，此时虽然值一样，但是我们的交换条件不满足，因此还是会保持原来位置  

但是，这种稳定性是我们人为可以打破的，如果把交换条件改成`array[j]>=tmp`，那就会交换位置，导致位置变化，比如`2(红) 5 2`-->`2 5 2(红)`  

因此，如果一个排序本身是稳定的，那它一定可以转变成不稳定排序  
反之，如果这个排序本身就不稳定，那它就不可能稳定了  

### 2. 希尔排序（插入排序Plus版）

我们的希尔排序又叫缩小增量排序，它的核心就是**分组**，然后让每一组进行插入排序  
排序后每一组内部都是有序的了，然后我们再次分组，比上次分组少，然后再排序，再分组，直到分为一组，然后排序，这下整体就是有序的了  

你问为什么它比插入排序更牛，其实是因为你每一组数据都比较少，然后你排完序再分组的时候，由于上一次排序让部分数字有序了，因此你这一次分组虽然每组数字比上次多  
但是每组数字都是比上一次有序了，实际上这一次排序比上一次排序工作量更小，因此也就造就了数据越有序，排序就越高效  

好，在希尔排序中，我们把每次分的组总数叫做`gap`，关于这个组怎么分呢，其实现在科学界并无确切定论  

有跳跃式分组：即当前数字和后面不想领数字为一组，这样就有一个好处，就是可以让大的数字往后边走，小的数字往前面来  
还有我们可以对半分，即每次分组除以2，或者是对三分，除以3都可以，我们就以对半分为例  
这个逻辑还是跟之前直接插入排序类似  
![image-20250802094947758](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508020949929.png)
好，为什么我们每次让`j`要往前走`j-gap`步呢？  

你想，我们希尔排序本质上就是对**对一组内进行排序**，如果`j--`，那是不是会导致不同的组进行排序，就比如`8(红色那组) 6(蓝色那组) 9(红色那组)`，如果我们`i`等于9，`j`等于8，这样只是在红色那一组内排序，符合希尔排序要求  

但是如果我们`i`等于9，`j`等于8，会导致我们在蓝色和红色组内排序，不符合希尔排序要求  
当我们两组再排完序之  
我们再把所有数字看成一个整体再进行排序，由于上一次排序部分数字是有序的，因此我们这一次排序就比上次高效的多  

我们让初识`gap`等于数组长度，即每个元素看成一组，然后每次除以2分组，直到分为一组  
说白了就是几组数字交替排序  
```java
//希尔排序
public void shellSort(int [] array){
    int gap = array.length;
    while(gap > 0){
        //gap指的是希尔排序中同组元素的索引差
        //它是两组两组交替排序的
        //为什么gap>1，因为如果最后分到一组，其实已经有序了，无需再排
        gap /= 2;
        shell(array,gap);
    }
}

//每一轮希尔排序
private void shell(int[] array, int gap) {
    //每一次排序都从中间位置往后走，每一次都是和同组的组内元素进行交换
    for(int i = gap;i <array.length;i++){
        int tmp = array[i];
        int j = i - gap;
        for(;j >= 0;j-=gap){
            if(array [j] > tmp){
                //关键一步
                array[j+gap] = array[j];
            }else{
                break;
            }
        }
        //将当前待插入元素 tmp放到同组中已挪出位置的正确位置，完成该元素在当前 gap分组下的插入排序。
        array[j+gap] = tmp;
    }
}
```
由于希尔排序对`gap`分组极其敏感，目前又尚无定论，因此时间复杂度并不能确定，但是目前测算比较准确的是在$n^1.3 ~ n^1.5$之间  
因此我们和直接插入排序的时间复杂度比较O($n^2$)，因此这就是为什么说希尔排序是直接插入排序的高效版本，但是希尔排序是不稳定排序，本质原因在于**分组跳跃式交换机制**  

举个例子  
![image-20250907084758057](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202509070847366.png) 
![image-20250907084814890](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202509070848077.png)  

### 3. 选择排序  
本质上就是数字的交换，且看我图解  
![image-20250802102320983](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508021023135.png)

```java
//选择排序
    public void selectSort(int [] array){
        for(int i = 0;i<array.length;i++){
            int minIndex = i;
            for (int j = i+1; j < array.length; j++) {
                if(array[j] < array[minIndex]){
                    //更新最小值下标
                    minIndex = j;
                }
            }
            //如果遍历一圈下来最小值下标就是i本身，就没必要交换了，这是错误的
            //if(i == minIndex){
            //    break;
            //}
            //添加 if(i == minIndex) { break; }会导致选择排序提前终止
            //无法保证所有元素都被正确排序。即使在某些情况下结果正确，也只是巧合。
            //选择排序的正确实现应该遍历所有位置（从0到n-2），即使某些位置已经是最小值
            //也需要继续处理后续位置，以确保整个数组有序。
            //说明此时minIndex中的下标值就是最小值
            int tmp = array[i];
            array[i] = array[minIndex];
            array[minIndex] = tmp;
        }
    }
```
好，我们来分析时间复杂度，由于每次都要排序比当前下标少一个的次数，因此还是等差数列，求和好时间复杂度还是O($n^2$)  
由于没有申请额外空间，空间复杂度就是O(1)  
而且它不稳定，我们每一轮排序都有跳跃式交换数字  
```java
int tmp = array[i];
array[i] = array[minIndex];
array[minIndex] = tmp;
```

### 4. 测试三种排序效率  
```java
public static void main(String[] args) {
        //测试，倒序数组
        int [] array = new int[200000];
        for(int i = array.length-1;i >= 0 ;i--){
            array[i] = i;
        }
        //测试，正序数组
        int [] arrays = new int[200000];
        for(int i = 0;i < arrays.length;i++){
            arrays[i] = i;
        }
        //测试，随机数组
        Random random = new Random();
        int [] arrayss = new int[50000];
        for (int i = 0; i < arrayss.length; i++) {
            arrayss[i] = random.nextInt(150);
        }

        //测试插入排序
        testInsertSort(array);
        testInsertSort(arrays);
        testInsertSort(arrayss);

        //测试希尔排序
        testShellSort(array);
        testShellSort(arrays);
        testShellSort(arrayss);

        //测试选择排序
        testSelectSort(array);
        testSelectSort(arrays);
        testSelectSort(arrayss);
    }

    public static void testInsertSort(int [] array){
        MySort mySort = new MySort();
        array = Arrays.copyOf(array,array.length);
        Long startTime = System.currentTimeMillis();
        mySort.insertSort(array);
        Long endTime = System.currentTimeMillis();
        System.out.println("直接插入排序时间差是："+(endTime-startTime));
    }

    public static void testShellSort(int [] array){
        MySort mySort = new MySort();
        array = Arrays.copyOf(array,array.length);
        Long startTime = System.currentTimeMillis();
        mySort.insertSort(array);
        Long endTime = System.currentTimeMillis();
        System.out.println("希尔排序排序时间差是："+(endTime-startTime));
    }

    public static void testSelectSort(int [] array){
        MySort mySort = new MySort();
        array = Arrays.copyOf(array,array.length);
        Long startTime = System.currentTimeMillis();
        mySort.insertSort(array);
        Long endTime = System.currentTimeMillis();
        System.out.println("选择排序时间差是："+(endTime-startTime));
    }
```
![image-20250802105506449](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508021055581.png)
但是记住，时间只是辅助验证，即使时间复杂度不一样，但是时间也是存在相同情况  
就比如我的选择排序和直接插入排序时间复杂度是一样的，但是时间差却不同  
因此$时间复杂度≠时间差$  

### 5. 堆排序  
已经在优先级队列中写过了，这里就不再赘述，时间复杂度是O(nlogn)，而且不稳定，没有额外申请空间则空间复杂度是O(1)  

### 6. 快速排序  
快速排序就是在当前区间中选取一个基准值，然后把当前区间划分成两个区域  
左边区域小于等于基准值，右边区域大于等于基准值  
然后再去递归组有两个区间，当最后区间内元素只剩下一个的时候，此时再去递归左右区间就没有意义了，因此终止  

关于如何选择划分区域  
#### 1. 霍尔法  
就是每次选取区间最左边或者是最右边的值，然后遍历这个区间  
因为我们要让区间划分成两个区域，因此我们左右端点各定义两个指针，然后分别去遍历我的当前区域  
右指针的值，如果右指针的值大于基准值，说明其不需要移动  
但凡小于**等于**基准值，说明这个下标值需要放到左边去，但是先别急
左指针的值如果小于基准值，说明其不需要移动  
但凡大于**等于**基准值，说明这个下标值需要放到右边去  
此时正好左指针的值要放到右边，右指针的值要放到左边，正好交换  
就这样一直循环，直到两个指针相遇，此时左边区域都是小于等于基准值，右边区域都是大于等于基准值  
此时我们再把基准值放到这个位置，然后返回此时基准值下标，去递归左右两个区域......
```java
//霍尔法
    private int partitionH(int [] arrays,int left,int right){
        int key = arrays[left];
        int l = left;
        int r = right;
        while(l < r){
            while(l < r && arrays[r] >= key){
                r--;
            }
            while(l < r && arrays[l] <= key){
                l++;
            }
            swap(arrays,l,r);
        }
        swap(arrays,left,l);
        return l;
    }
```
![image-20250909110651532](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202509091106803.png)
为什么比较条件要取`=`，比如这种情况  
`[6 6 4 6]`  
`l       r`  
此时`l`和`r`会一直交换，死循环了  
为什么指针移动要加上`l < r`呢，因为你想如果我数组是完全有序的，一直移动不会越界吗  
`[1 2 3]`，基准值是1  
`l  <--r`  
此时`r`就会超出`l`，越界  

#### 2. 挖坑法  
这个说白了就是刚刚我们不是右指针走到要交换的位置，然后让左指针往后走，走到要交换的位置吗  
这个方法我们在右指针走到要交换的位置后直接与左指针的值交换，不需要等到左指针走完  
同理左指针走到要交换的位置，直接和右指针进行交换，不需要等到右指针走完  
当两个指针相遇后，我们再把基准值`key`放入这个位置，再递归左右两个区间  
```java
//挖坑法
    private int partitionW(int [] arrays,int left,int right){
        int l = left;
        int r = right;
        int key = arrays[left];
        while(l < r){
            while (l < r && arrays[r] >= key){
                r--;
            }
            swap(arrays,l,r);
            while (l < r && arrays[l] <= key){
                l++;
            }
            swap(arrays,l,r);
        }
        arrays[l] = key;
        return l;
    }
```
![image-20250909112612912](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202509091126050.png)

#### 3. 双指针法  
这个就比较有意思了，还是一样选择数组最左边作为基准值，然后定义两个指针去遍历数组  
一旦右指针的值比我的基准值大，我们左指针往后走一步先看看是不是和我们的右指针值相等，不想等才进行交换  
最后右指针遍历完数组，我们再把基准值放在左指针位置  
此时我的左指针左边区域是大于基准值的值，右边区域是小于等于基准值的值  
```java
//双指针法
    private int partitionS(int [] arrays,int left,int right){
        int l = left;
        int r = left+1;
        while(r <= right){
            if(arrays[r] > arrays[left] && arrays[++l] != arrays[r]){
                swap(arrays,l,r);
            }
            r++;
        }
        swap(arrays,left,l);
        return l;
    }
```

#### 4. 优化

首先是三数取中，我们的其中一种思路就是选取最左侧、最右侧及中间下标的三个值  
去比较，选出中间值，然后放在最右侧的前一个下标位置，之后进行比较  
比较完毕后，再把基准值放在正确位置  
```java
//三数取中法
    private int partitionGetMiddle(int [] arrays,int left,int right){
        //获取中间元素下标
        int middle = left+(right-left)/2;

        //三个数排下序
        // 比较左端、中间和右端三个元素的值，并重新排列它们
        // 目标：确保 array[left] <= array[midIndex] <= array[right]

        // 如果左端元素大于中间元素，交换它们
        if (arrays[left] > arrays[middle]) {
            swap(arrays,left,middle);
        }

        // 如果左端元素大于右端元素，交换它们
        if (arrays[left] > arrays[right]) {
            swap(arrays,left,right);
        }

        // 如果中间元素大于右端元素，交换它们
        if (arrays[middle] > arrays[right]) {
            swap(arrays,middle,right);
        }

        //因为我们此时已经知道最右侧的值是三个数中最大的了
        //因此我们把中间值放到最右侧的左边
        int key = arrays[middle];
        swap(arrays,middle,right-1);

        //左右定义两个指针，小于基准值的值放在左边，大于的放在右边
        int l = left;
        int r = right;
        while(true){
            l++;
            //如果是小于的，符合要求，直接跳过
            while(arrays[l] < key){
                l++;
            }
            r--;
            //如果是大鱼的，符合要求，直接跳过
            while(l < r && arrays[r] > key){
                r--;
            }
            //此时说明两个指针的值都是不符合要求的，说明要进行交换
            if(l >= r){
                break;
            }
            swap(arrays,l,r);
        }
        //此时再把基准值放在正确位置，即l下标
        swap(arrays,l,right-1);
        return l;
    }
```
以下是图示讲解  
![image-20250909192222129](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202509091922385.png)
![image-20250909192249372](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202509091922571.png)  
再者，我们可以再优化：  
快速排序它是越有序时间复杂度越高，会退化成O(n^2)，因此在当前区间长度比较小的时候，我们可以使用插入排序  

#### 5. 迭代快排  
既然递归层次太深,有时候会导致内存爆掉,因此我们可以使用迭代方法换取空间  
选取基准值划分区域还是跟刚刚一样的代码，只是现在是模拟递归过程  
去递归基准值左边和有边的区间  
```java
//迭代使用栈实现快排
    import java.util.Stack;

class Solution {
    public int[] sortArray(int[] nums) {
        quickSortPlus(nums, 0, nums.length - 1);
        return nums;
    }

    private void quickSortPlus(int[] arrays, int left, int right) {
        Stack<Integer> stack = new Stack<>();
        // 压入初始边界
        stack.push(left);
        stack.push(right);
        while (!stack.isEmpty()) {
            // 弹出右边界和左边界
            int r = stack.pop();
            int l = stack.pop();
            if (l < r) {
                int index = partitionGetMiddle(arrays, l, r);
                // 压入左子数组边界
                if (index - 1 > l) {
                    stack.push(l);
                    stack.push(index - 1);
                }
                // 压入右子数组边界
                if (r > index + 1) {
                    stack.push(index + 1);
                    stack.push(r);
                }
            }
        }
    }

    private int partitionGetMiddle(int[] arrays, int left, int right) {
        // 三数取中
        int middle = left + (right - left) / 2;
        if (arrays[left] > arrays[middle]) {
            swap(arrays, left, middle);
        }
        if (arrays[left] > arrays[right]) {
            swap(arrays, left, right);
        }
        if (arrays[middle] > arrays[right]) {
            swap(arrays, middle, right);
        }
        // 将基准值放到 right-1 位置
        int key = arrays[middle];
        swap(arrays, middle, right - 1);
        
        // 初始化指针
        int l = left;
        int r = right - 1;
        while (true) {
            // 左指针向右移动，找到第一个大于等于基准值的元素
            while (l < right - 1 && arrays[++l] < key) ;
            // 右指针向左移动，找到第一个小于等于基准值的元素
            while (r > left && arrays[--r] > key) ;
            if (l >= r) {
                break;
            }
            swap(arrays, l, r);
        }
        // 将基准值放回正确位置
        swap(arrays, l, right - 1);
        return l;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}

```

### 7. 归并排序  
归并排序之间算法文章已经讲过了  
我们之前定义的临时数组是全局的，我们也可以定义局部的，每次递归创建数组，其实占不了多大的内存  
```java
//归并排序
    int [] temp;
    public int[] sortArray(int[] nums) {
        temp = new int[nums.length];
        sortArrayPlus(nums,0,nums.length-1);
        return nums;
    }

    private void sortArrayPlus(int [] nums,int left,int right){
        if(left >= right){
            return;
        }
        int middle = (left+right)/2;
        sortArrayPlus(nums,left,middle);
        sortArrayPlus(nums,middle+1,right);

        //合并有序数组
        int current1 = left;
        int current2 = middle+1;
        int pos = 0;
        while(current1 <= middle && current2 <= right){
            if(nums[current1] <= nums[current2]){
                temp[pos] = nums[current1];
                current1++;
            }else{
                temp[pos] = nums[current2];
                current2++;
            }
            pos++;
        }

        //处理剩下元素
        while(current1 <= middle){
            temp[pos] = nums[current1];
            current1++;
            pos++;
        }
        while(current2 <= right){
            temp[pos] = nums[current2];
            current2++;
            pos++;
        }

        //将结果重新放入数组中
        for(int i = left;i <= right;i++){
            nums[i] = temp[i-left];
        }
    }
```
无论数组是否有序，时间复杂度都是`nlogn`  
对于空间复杂度，由于递归关乎栈内存，因此我们递归深度说白了就是树的高度，为`logn`  
但是，你的临时数组最大是和原数组长度相等的，因此空间复杂度是`n`  
综上，空间复杂度就是`n`  

***

我们接下来讲讲非递归实现  
因为我们要模拟递归过程，因此我们分组的最开始的元素个数是1，进行有序数组合并  
我们定义变量`gap`代表每一组内的元素个数  
![image-20250911103027363](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202509111030674.png)

但是这样存在一个问题，如果是这样  
![image-20250911103327891](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202509111033011.png)
`mid`和`right`出现越界情况，是不是就不能进行排序啊，因此我们迭代的时候要判断  

```java
//归并迭代实现
    public int [] sortArrayPlus(int [] arrays){
        int length = arrays.length;
        int gap = 1;
        temp = new int[length];
        while(gap < length){
            for(int i = 0;i < length;i+=gap*2){
                int left = i;
                int middle = left+gap-1;
                if(middle >= length){
                    middle = length-1;
                }
                int right = middle+gap;
                if(right >= length){
                    right = length-1;
                }
                //合并有序数组
                int current1 = left;
                int current2 = middle+1;
                int pos = 0;
                while(current1 <= middle && current2 <= right){
                    if(arrays[current1] <= arrays[current2]){
                        temp[pos] = arrays[current1];
                        current1++;
                    }else{
                        temp[pos] = arrays[current2];
                        current2++;
                    }
                    pos++;
                }

                //处理剩下元素
                while(current1 <= middle){
                    temp[pos] = arrays[current1];
                    current1++;
                    pos++;
                }
                while(current2 <= right){
                    temp[pos] = arrays[current2];
                    current2++;
                    pos++;
                }

                //将结果重新放入数组中
                for(int j = left;j <= right;j++){
                    arrays[j] = temp[j-left];
                }
            }
            gap *= 2;
        }
        return arrays;
    }
```
因此如果数据量非常大，我们一般会切成小块，分别使用归并排序  
最后排序完成再整合到内存中，这样就可以减小内存压力了  

### 8. 计数排序  
这个原理很简单，我们就定义一个计数数组，其大小就是原数组`最大值-最小值+1`  
然后遍历原数组，将各个数值出现的次数进行统计，之后再放入原数组中  
![image-20250911105251820](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202509111052960.png)

虽然空间复杂度比较高，但是时间复杂度比较低，等于是用空间换时间了  
时间复杂度：max(数据量，数据范围)  
空间复杂度：跟数据范围有关，范围大需要的数组就大  
稳定性：是一个稳定的排序，因为我们引入了一个计数数组，并没有改变原数组中同一个值的相对位置  

```java
//计数排序
    public int [] countSort(int [] arrays){
        //检索最大值最小值
        int length = arrays.length;
        int max = arrays[0];
        int min = arrays[0];
        for(int i = 1;i < length;i++){
            if(arrays[i] > max){
                max = arrays[i];
            }
            if(arrays[i] < min){
                min = arrays[i];
            }
        }
        int [] count = new int[max-min+1];
        //开始计数
        for (int array : arrays) {
            count[array - min]++;
        }
        //返回原数组
        //标记原数组下标用的
        int pos = 0;
        for(int i = 0;i < max-min+1;i++){
            while(count[i] != 0){
                arrays[pos] = i;
                count[i]--;
                pos++;
            }
        }
        return arrays;
    }
```

可以看到代码中计数是减去了最小值偏移量，这样做可以大大减少我们数组内存开销  

但是，很显然，计数排序有个缺点，就是如果最大值和最小值即数据范围过大，会导致非常多的空间浪费  

### 9. 基数排序  
这个排序就很有意思了，说白了就是对每个数的个位十位百位千位等等进行排序  
![image-20250911111219928](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202509111112076.png)

我们要进行几次入队和出队，取决于最大值它是几位数，这个很容易理解  
```java
//基数排序数组版本
    public static void radixSortWithArrays(int[] array) {
        // 找到数组中的最大值，确定需要多少位
        int maxValue = findMaxValue(array);

        // 计算最大位数
        int maxDigitCount = countDigits(maxValue);

        // 创建10个桶（0-9）
        int[][] buckets = new int[10][array.length];
        // 记录每个桶中的元素数量
        int[] bucketSizes = new int[10];

        // 从最低位到最高位进行排序
        for (int digitIndex = 0; digitIndex < maxDigitCount; digitIndex++) {
            // 将元素分配到桶中
            for (int num : array) {
                int digit = getDigit(num, digitIndex);
                buckets[digit][bucketSizes[digit]++] = num;
            }

            // 从桶中收集元素
            int index = 0;
            for (int i = 0; i < 10; i++) {
                for (int j = 0; j < bucketSizes[i]; j++) {
                    array[index++] = buckets[i][j];
                }
                bucketSizes[i] = 0; // 重置桶大小
            }
        }
    }

    // 辅助方法：找到数组中的最大值
    private static int findMaxValue(int[] array) {
        int max = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i] > max) {
                max = array[i];
            }
        }
        return max;
    }

    // 辅助方法：计算数字的位数
    private static int countDigits(int number) {
        if (number == 0) {
            return 1;
        }
        return (int) Math.log10(Math.abs(number)) + 1;
    }

    // 辅助方法：获取数字的特定位数上的数字
    private static int getDigit(int number, int digitIndex) {
        return (int) ((number / Math.pow(10, digitIndex)) % 10);
    }
```

还可以使用优先级队列类`PriorityQueue`，这个稍微慢一点，但是无需手动维护内存  

```java
public static void radixSortWithArrays(int[] array) {
        // 找到数组中的最大值，确定需要多少位
        int maxValue = findMaxValue(array);
        
        // 计算最大位数
        int maxDigitCount = countDigits(maxValue);
        
        // 创建10个桶（0-9）
        int[][] buckets = new int[10][array.length];
        // 记录每个桶中的元素数量
        int[] bucketSizes = new int[10];
        
        // 从最低位到最高位进行排序
        for (int digitIndex = 0; digitIndex < maxDigitCount; digitIndex++) {
            // 将元素分配到桶中
            for (int num : array) {
                int digit = getDigit(num, digitIndex);
                buckets[digit][bucketSizes[digit]++] = num;
            }
            
            // 从桶中收集元素
            int index = 0;
            for (int i = 0; i < 10; i++) {
                for (int j = 0; j < bucketSizes[i]; j++) {
                    array[index++] = buckets[i][j];
                }
                bucketSizes[i] = 0; // 重置桶大小
            }
        }
    }
    
    // 辅助方法：找到数组中的最大值
    private static int findMaxValue(int[] array) {
        int max = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i] > max) {
                max = array[i];
            }
        }
        return max;
    }
    
    // 辅助方法：计算数字的位数
    private static int countDigits(int number) {
        if (number == 0) {
            return 1;
        }
        return (int) Math.log10(Math.abs(number)) + 1;
    }
    
    // 辅助方法：获取数字的特定位数上的数字
    private static int getDigit(int number, int digitIndex) {
        return (int) ((number / Math.pow(10, digitIndex)) % 10);
    }
```

### 10.桶排序

这个跟刚刚基数排序非常相似，只是不再是对位数进行排序，而是对范围内的数据进行排序  
![image-20250911113521936](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202509111135117.png)

```java
public static void bucketSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        // 找到数组中的最大值和最小值
        int minValue = arr[0];
        int maxValue = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] < minValue) {
                minValue = arr[i];
            } else if (arr[i] > maxValue) {
                maxValue = arr[i];
            }
        }
        
        // 计算桶的数量，这里使用数组长度的平方根作为桶数
        int bucketCount = (int) Math.sqrt(arr.length);
        if (bucketCount == 0) {
            bucketCount = 1;
        }
        
        // 创建桶
        List<List<Integer>> buckets = new ArrayList<>(bucketCount);
        for (int i = 0; i < bucketCount; i++) {
            buckets.add(new ArrayList<>());
        }
        
        // 将元素分配到桶中
        for (int num : arr) {
            // 计算元素应该放入哪个桶
            int bucketIndex = (int) ((num - minValue) * (bucketCount - 1) / (maxValue - minValue));
            bucketIndex = Math.min(bucketIndex, bucketCount - 1); // 确保索引不越界
            buckets.get(bucketIndex).add(num);
        }
        
        // 对每个桶进行排序（这里使用Collections.sort，实际可以是任何排序算法）
        for (List<Integer> bucket : buckets) {
            Collections.sort(bucket);
        }
        
        // 合并所有桶到原数组
        int index = 0;
        for (List<Integer> bucket : buckets) {
            for (int num : bucket) {
                arr[index++] = num;
            }
        }
    }
```
时间复杂度：最好的是元素分到各个桶中，即N个元素分到K个桶，为O(N+K)  
最坏则是都分到一个桶中，退化为类似于插入排序，为O(N^2)  
空间复杂度：O(N+K)，N个元素的数组和K个桶  

***

<center>文章错误不可避免，期待您的指正，我们共同进步</center>

***

<div align = center>
<a href = https://gitee.com/pluchon/career-in-java-data-structures/tree/master/TestProjectNew20250802/src>Git码云仓库链接 上</a>

<div align = center>
<a href = https://gitee.com/pluchon/career-in-java-data-structures/tree/master/TestProjectNew20250731/src>Git码云仓库链接 中</a>

<div align = center>
<a href = https://gitee.com/pluchon/career-in-java-data-structures/tree/master/LeetcodeSolution/src>Git码云仓库链接 下</a>

***

<center>END</center>