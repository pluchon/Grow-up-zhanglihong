# 硅基计划5.0 伍 事务

***

![图 (119)](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510211611019.png)

***

[toc]

***

## 一、定义  
事务指的就是某个具体功能是由多个SQL去完成的，比如转账操作  
```sql
update balance set money = money-50 where id = 1;
update balance set money = money+50 where id = 2;
```
但是有时候执行到一班，钱扣了却没有到账，对于这种情况，我们会设立事务，即把事务里面的所有SQL语句执行完了，才算某个功能实现了  
进而MySQL会自动记录这种过程，记录执行了哪些SQL，然后写在日志中，便于之后的代码回滚操作  
同样，对于物理因素比如服务器断电等，也可以进行回滚操作  
由于日志是写在硬盘上的，因此无需担心日志丢失，每次只有当最后一个SQL执行完毕后，日志才会销毁  

说了这么多，那么事务到底是什么，说白了就是对`sql`代码进行打包，本质上是解决原子性问题  
记下来我们要讲到事务的四个核心特征，这些是面试题常考的  

我们来说下基础语法  
```sql
start transaction; # 开始事务
......... # 写一些增删改查的sql语句
commit; # 事务提交，事务执行完毕
# rollback 对这条事务的执行结果进行回滚，即回到解放前
```

我们再来说下保存点  
如果你执行事务时，回滚的时候，可以回滚到你指定的位置  
```sql
# 保存点问题
create table tmp11(id int);
insert into tmp11 values(11);
begin;
update tmp11 set id = 12;
savepoint aaa;
update tmp11 set id = 666;
rollback to aaa;
select * from tmp11;
commit;
```
![image-20251021160512248](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510211605376.png)

最后再来说自动提交/手动提交  
我们可以通过语句展示  
```sql
show variables like 'auto cmooit';
set autocommit = 1;# 或者写set autocommit = on 开启自动提交
set autocommit = 0;# 或者写set autocommit = off 关闭自动提交
```

## 二、事务的四大特征  
### 1. 事务特征之一——原子性  
什么是原子性，因为我们多个`sql`语句是一个整体，任何一个`sql`语句出错，都会导致这个事务执行失败，从而触发回滚操作  

### 2. 事务特性之二——一致性  
什么是一致性，就是要保持数据的正确性，比如我们之前转钱的例子，我们钱扣了但是没有到账，这就是数据不一致

### 3. 事务特征之三——持久性  
事务对于数据的修改要持久生效，要把数据写入硬盘  

### 4. 事务特征之四——隔离性  
我们先解释下什么是并发  
并发就是由于`sql`服务器不只是对一个客户端进行服务，因此就会导致很多`sql`语句要一起执行  
#### 1. 脏读  
我们再解释下什么是**脏读**  
在事务1对一个数据进行修改的时候，事务1还没有进行提交（完成），事务2就进行了这条数据的读取，从而此时事务2读取到的就是一个被修改的数据  
但是此时万一事务1进行了回滚操作，这个值又恢复原样了，此时事务2读取到的就不是一个正确的数据，这个就是脏读  
我可以画一个时间轴的图来帮助大家辅助理解
![image-20251021145043911](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510211450163.png)
此时事务2读取到的就是一个错误的数据，即脏数据  

我们如何解决呢  
我们就要设定在事务1执行的过程中，如果事务2要查看数据，**只能等到事务1执行完毕提交后**才可以执行数据  

#### 2. 不可重复读  
在脏读的基础上，如果事务1在读取某个数据的时候，第一次读取读取到了这个数据的一个值`a`  
但是其他事务对这个数据进行了修改，这个数据值变成了`b`，进而会事务1再进行读取的时候，读取到了一个被修改过的数据`b`  
从而导致了在**同一个事务内的读取同一个数据多次出现了前后不一致的情况**  
![image-20251021150008363](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510211500458.png)
可以看到，我们事务1两次对同一个数据进行读取，由于其他两个事务进行了修改，导致了结果不一样  

我们如何解决呢  
我们要进行**加锁**，即一个事务在进行读取操作的时候，其他事务不能对这个事务读取的数据进行修改，必须要等到**这个事务执行完毕提交后**才可以进行修改  

#### 3. 幻读  
在同一个事务中某个查询得到的**结果集合**不一致  
我们举个例子，假如我们第一次查询得到了五条数据，但是在同一个事务内进行第二次查询的时候，得到了十条数据，这就是幻读  
我们同样画图进行举例  
![image-20251021150548327](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510211505396.png)

我们如何解决呢  
我们要对数据库进行**串行化**，即彻底让整个服务器逐个逐个执行事务  

## 三、隔离级别  
我们刚刚说了事务的四大特征，特别是针对隔离性的三大要点进行了讲述  
那么，MySQL有没有自己提供隔离级别，好让我们在创建数据库的时候自行选择呢？答案是有的  

### 1. MySQL自己提供的四大隔离级别

#### 1. read uncommitted  
这个隔离性是最弱的，可以承受高并发操作，但是我们刚刚讲的隔离性的三个问题都存在  

#### 2. read committed  
这个级别解决了脏读问题  

#### 3. repeatable read——默认  
这个是MySQL数据库默认的级别，针对脏读和不可重复读问题进行了解决，但是针对幻读问题进行了部分解决  

#### 4. serializable  
这个隔离性最强，但是由于是只能逐条执行事务，因此并发性为0，从而解决了所有隔离性问题  

### 2. 修改数据库的隔离性  
查询级别  
```sql
select @@global.transaction_isolation;
```
#### 1. 通过sql语句修改

```sql
set (global(全局)/session(局部)) transaction isolation level 具体级别;
```
但是请注意，我们执行语句修改后，并不是立即生效，而是要重新连接这个服务器才生效  
但是这种修改方式如果服务器重启了，那么修改就作废了  
#### 2. 修改配置文件  
我们找到`mysql serve8.0`的文件目录，打开`my.ini`进行修改就好，具体可以上网搜索  

### 3. 探讨不同级别的三种隔离性问题  
#### 1. 探讨脏读问题  
由于脏读问题是在最低级别下才出现，因此我们先修改数据库级别，写好`sql`语句后，重新开启一个连接  
![image-20251021153338488](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510211534749.png)
我们在执行左边事务1的更新操作，然后再次读取  
![image-20251021153532829](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510211535068.png)
好，现在就显而易见了，两次读取的数据都不一致，这就是脏读问题  

#### 2. 探讨不可重复读问题  
我们把数据库级别再升一个档次，然后再进行查询  
![image-20251021154229511](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510211542764.png)
![image-20251021154327877](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510211543040.png)
可以看到我们由于有其他事务对值进行了修改，就导致了数据读取的结果不一致，这就是不可重复读问题  

#### 3. 探讨幻读问题  
我们再把数据库级别提升一个档次，即默认的档次，然后进行一些操作  
![image-20251021154925098](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510211549307.png)
![image-20251021155030695](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510211550825.png)
诶，因为我之前说过，解决了部分幻读问题，因此此时读取结果是正确的  

但是如果我把`id`列修改为主键约束`primary key`，再进行插入重复值，看能成功吗  
如果能成功，说明能够感知到重复值存在，说明还是存在幻读问题  
![image-20251021155333308](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510211553423.png)
结果显而易见，察觉到了外键存在，还是存在读取问题

好，我们直接给到最高级的隔离级别再看看  
![image-20251021155812371](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510211558577.png)
我们发现，当右边事务在执行的时候，左边事务想插入一条合法数据，但是由于是串行化执行，要等到右边事务执行完毕后才能执行，存在等待的过程  
![image-20251021155912285](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510211559537.png)
提示等待超时，因此最高隔离级别它的隔离性非常高，但是代价就是不存在并发性  

***

<center>希望本篇文章对您有帮助，有错误您可以指出，我们友好交流</center>

***
<center>END</center>