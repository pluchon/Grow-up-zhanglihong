# 硅基计划5.0 MySQL 肆 索引

***

![1758766226218](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510191147232.png)

***

[toc]

***

## 一、初识索引  
索引在数据库中具体表现为一种特殊的数据结构，我们想想，在之前讲的Java数据结构中  
对于快速查询的数据结构有哈希表、红黑树、二叉搜索树等等，但是为什么它们都不适合用于数据库索引呢  
我们先看哈希表，哈希表用于对**确定的数据**进行查询，比如我想查询哈希数组中下标为5中的指定数据，而无法指定范围查找，比如我想查询哈希数组中从下标5到下标8的指定数据  
其次我们再看红黑树和二叉搜索树，虽然可以确定范围，但是重点是数据多了之后树的高度会变得很高  
因为我们之前讲数据结构都是在内存中进行比较，速度快，但是我们MySQL数据是存储在硬盘中的，每一次比较都要触发读盘操作，非常耗时且效率低  

因此，有没有一种数据结构，既能满足范围查找，又得让树的高度尽可能低呢？有的，这就是我们要讲的B+树  

### 1. B树  
讲B+树之前，我们先来认识下B树  
B树本质上就是一个**N叉搜索树**，即跟我们之前二叉搜索树结构类似，只不过每个节点都有**N个子树**，这样做就可以显著降低树的高度  
![image-20251019100847835](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510191008967.png)
即使要比较多次，但是每次都是在节点内比较，读盘次数显著变少  

### 2. B+树  
在认识到B树后，我们再来看看B+树针对B树又做了哪些优化  
B+树整体结构式这样的，还是一样的每个节点有N个子树，但是  
1. 每个节点的最后一个值是当前节点内的最大值  
2. 父节点中的值会以**最大值**出现在每个子节点中  
3. 只有叶子节点存放真正的数据，其他节点都是存的索引，每个索引都有对应的在叶子节点的数据 行  
4. 对于所有的叶子节点，会使用双向链表进行全部连接  
5. 到了最后叶子节点，所有叶子节点的值，就是整个数据集的合集  
6. 我们约定，B+树的高度最好不要超过3层  

这么讲太干巴了，直接画个图来帮助理解  
![image-20251019102444467](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510191024612.png)
如图所示，这就是最简易的B+树，索引的生成必须要有指定，比如你用`primary key`约束某个列或者是使用`unique`约束某个列或者是其他的等等约束都可以  

B+树的设计，对于MySQL的索引查找是有非常大的好处的，具体表现是  
1. 高度低：首先是N叉搜索树本身高度就比较低，其次是我们把当前节点的最大值作为每一个子节点的最大值，又降低了高度，这样我们的读盘次数少了，效率就高了  
2. 稳定性：因为我们的数据行都是在叶子节点上，因此每一次查询都要落到叶子节点，保证了稳定性  
3. 适合范围查找：观察我们刚刚的图，由于我们每个叶子节点都是相连的，因此当我们指定范围，比如查询数据行号在5~15范围内的数据，我们仅需找到数据行号等于5的位置，再往后遍历到15就好了，大大提高效率。而如果对于普通的树，则要进行回溯后再递归查询，耗时  
4. 由于索引是存在内存中的，数据存在硬盘中，并且索引占据空间小，进一步减少读盘次数  

### 3. MySQL的页  
这个页说白了就是B+树的**每一个节点**，进而可以知道有索引页和数据页，默认大小是16kb，在读写操作中，我们都是以页为单位的，而每个表我们都可以看出一个页  
我们之前说过所以你的创建需要主键来确定，即使没有主键，MySQL还是会隐式的添加一个列作为索引列  

我们在计算机领域中，有一个通过大量开发经验得出来的结论，叫**局部性原理**  

* 空间局部性：某时某个程序读取了某个数据，以后大概率还会再读取一次这个数据的邻近的数据  
* 时间局部性：某个程序某时读取了某个数据，那么以后大概率还会用到这个数据  

#### 1. 经典面试题——计算三层树高的B+树大概可以存放多少条数据  
这个面试题非常经典，但是有一部分人只知道结果，当HR一问如果数据不统一怎么办，因此我们要知道这个是怎么算的  
首先，我们先约定几条规则  
1. 假设表中的主键使用8字节的数据  
2. 假设每个页的编号都是6个字节，这么算下来，每一个索引数据（一个索引行）就是14个字节  
3. 我们对于每个页的大小，都是忽略叶头和叶尾的一些信息，假设每个页（每个节点）16kb大小存的都是存的索引行  
因此我们计算一个索引页（一个节点）可以存多少个索引行呢：`16*1024/14 = 1170条`  
4. 由于叶子节点都是数据行，因此索引实际存放的是两层树高，并且假设每个数据行占用1kb，即1024字节，结合之前约定的一个节点大小是16kb，因此每个叶子节点都可以保存16条数据  
综合计算下来，`1170(第一层所派生出的索引行个数)*1170（第二层再派生出的索引行个数,此时已经有了1170*1170个叶子节点）*16 ≈ 2100万`  
因此粗略估计可以存放2100万条数据，当然实际结果和这个差别还是有的，我们刚刚是忽略了很多因素，还自定义指定列大小，实际上每个B+树还是有差异的  

#### 2. 优化树的高度  
我们如果B+树的高度超过了3层，如何处理呢，这里给出两中思路  
1. 冷热分离：我们数据库领域有一个二八原则（甚至可以是一九原则），即20%的数据它的使用频率是80%。因此我们借助这个特性，根据相关日志，把表分成两个表  
2. 分库分表：我们按照一定的开发规则，比如我们把不同自动分成不同的表，我们根据字段进行哈希切分，比如`班级id%3`，因此我们就可以根据结果分成三个表  

## 二、索引进阶及其分类

在一个表中，我们可以有多个索引，我们创建索引后，要指定索引列举进行查找才可以命中索引  
### 1. 主键索引  
就是我们之前讲的`prinary key`，指定主键的时候会自动创建一个索引列，如果未指定会生成隐藏列

### 2. 唯一索引  
就是我们讲过的`unique`关键字  

### 3. 普通索引  
这是是要我们自己根据SQL语句创建的  

### 4. 主键索引/非主键索引查找  
我们指定的主键列索引是根据B+树来创建的，但是对于**非主键字段**的索引列，我们叶子节点那存的不是数据行，而是一个个**主键id**  
因此在一个表中，即使有多个索引列，但是最后真正存放数据的，还是只有主键索引的B+树  
因此我们对于使用非主键索引查询的时候，会**先**到当前非主键索引B+树找到对应的主键id，**再**拿着这个主键id返回到主键索引的B+树中去查找真正的数据行  

### 5. 聚集索引/非聚集索引  
仅仅针对于我们数据库引擎`InnoDB`来说，它主要负责将数据存储到硬盘上，有自己的一套规则，而我们上述讲的所有规则，都是这个主流引擎的规则  

### 6. 索引覆盖  
我们使用`select`语句的时候，我们想要查询的内容已经是包含了索引列，因此无需再把查询结果返回到索引列中进行查找（这个操作叫做回表）  

## 三、使用索引  
### 1. 自动创建  
使用`primary key`、`unqiue`和`foreign key`创建会自动生成，而且未指定也会隐式生成  

### 2. 手动创建  
我们当然也可以自己指定索引列，分为三种方法  
1. 建表时指定  
```sql
create table tmp(id int primary key,name varchar(20),index(name));
```
2. 修改表结构  
```sql
create table tmp1(id int primary key,name varchar(20));
alter table tmp1 add index(name);
```
3. 建表后单独再创建  
```sql
create table tmp2(id int primary key,name varchar(20));
create index name_const on tmp2(name);
```

但是盲目创建索引其实是一个非常危险的操作，如果是在运行中的MySQL服务器，而且是一张非常大的表，由于索引你要建立B+树，会频繁进行读盘写盘操作，占用服务器带宽  
因此我们尽可能的在建表的时候就指定好创建好，可以避免很多麻烦  

但是你就是想创建索引怎么办呢  
其实我们可以利用冗余法，什么意思，就是先让旧的服务器先跑着  
我们创建一个和旧服务器功能结构一模一样的新服务器，然后我们把索引创建好，再把数据拷过来，再把提供服务的旧服务器端口接到新服务者来  
就可以以毫秒级别的不影响生产环境地切换到新的服务器  

### 3. 查看是否使用索引  
我们可以通过`explain`关键字查看索引使用情况  
```sql
explain 查询类型;
```
![image-20251019114122936](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510191142546.png)
对于`type`一栏，`all`代表的是全表查询，`const`代表的是查询使用了主键索引，`ref`代表查询使用了普通索引  

## 四、删除索引

这是一个危险操作，因为如果一旦删除，那树的叶子节点的数据的原有秩序会被打乱，因此如果不是用索引，就放在那，不要盲目删除  
```sql
alter table tmp drop index name;
```

## 五、索引失效问题  
我们在给一个表创建索引的时候，并不是所有的查询都是通过索引完成的  
### 1. 单个列索引  
1. 未在查询中使用索引列  
2. 即使使用了索引列，但是索引列的值单一，比如姓名表中的性别列，只有`男`和`女`两个结果  
3. 查询的时候对索引列进行了表达式计算，比如`where id + 10 < 50`。由于在B+树中，每个索引行都是确定的，如果使用表达式计算，还要修改每个索引节点的索引分布，太麻烦  
4. 查询条件中使用了`or`作为连接条件，一边是包含索引列的条件，一边不是，比如`where id < 10 or gender = '男'`。这样会导致有歧义性，我们的`gender`关键字不能进行索引查询。但是如果使用的是`and`，比如`where id < 10 and gender = '男'`，这样会先去`id`所在的B+树中找到对应结果，再拿着这个结果去`gender`列去搜寻结果  
5. 字符串查询时使用`like`模糊匹配，比如查找`%张`，我们如果使用姓名作为B+树索引，一般都会根据性别区分来，但是当前查找的是以`张`字结尾的，就不能够搜寻。如果改为`张%`就可以，因此**通配符不可以放在字符串开头**  
6. 针对索引列查询，如果使用`!=`或者是`not null`、`not`等这种模糊的查询，就不可以。但反之使用指定范围性质的诸如`= < > <= >= null`等进行查询，由于是已经明确了范围，因此就可以命中索引  
7. 多表联合查询的不同表字符集不一致，会导致查询时进行隐式转换  

### 2. 复合索引  
这个在开发中很少用到，即使用复合主键创建索引  
比如我们一个表有四列`1 2 3 4`，我们指定第`1`列和第`2`列作为复合主键，共同创建索引  
我们要先根据第`1`列的值创建好后，再根据第`2`列的值创建，什么意思呢  
![image-20251019113908391](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202510191139501.png)
但是如果打破这种创建顺序，就会导致索引直接失效了  

## 六、总结  
以上所有的内容都是我们对索引的初步认识，讲的比较浅，并没有深入去讲原理  
比如`页`的具体结构是什么，并没有细讲  
在以后的学习中，随着进一步的学习，我会把这一块内容补上  

***

<center>希望本篇文章对您有帮助，有错误您可以指出，我们友好交流</center>

***
<center>END</center>