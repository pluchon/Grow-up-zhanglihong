# 硅基计划4.0 算法 快排

***

![图 (244)](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508261041785.png)

***

[toc]

***

## 一、颜色分类  
[题目链接](https://leetcode.cn/problems/sort-colors/)  
我们的核心就是双指针，跟我们之前讲双指针的移动零类似  
我们定义指针`i`用于扫描数组，定义`left`和`right`分别标记`0`区域最右侧（包括零）和`2`区域的最左侧（包括零）  
因此我们具体来讲解下区域的划分  
![image-20250826095754530](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508260957776.png)

好，我们来讨论下`i`下标对应的各个值的情况  
1. 若`nums[i] == 0 `  
我们要让这个0加入`I`这个区域  
但是因为`left`表示的是`0`区域的最右侧，并且包括零，因此我们要放入其右侧，即`left+1`的位置  
说白了就是要让`nums[i]`与`nums[left+1]`交换  
然后`left`和`i`各自向后移  
倘若`left+1`的位置是非0元素，此时是符合`II`区域的特征的，我们直接`i++`就好  
有一个极端情况，就是`i`的位置正好在`left+1`的位置，如果恰好`i`位置（此时也就是`left+1`位置）的值也是0，相当于自己与自己交换，交换完后还是`i++`，`left++`  

2. 若`nums[i] == 1`  
因为我们`II`区域就是放`1`数字的，因此我们的`i`直接`i++`向后走就好  

3. 若`nums[i] == 2`  
我们要保证我们的2加入`IV`这个区域，因此跟刚刚等于0的操作类似，我们让`nums[i]`和`nums[right-]`位置的值交换即可，然后`right--`就好  
但是有一个要注意的点，为什么不能让`i++`呢？  
你想，我们`III`区域是带扫描的数，交换`nums[right-]`位置的元素的时候，这个元素实质上是在`III`区间的，也是待扫描的数  
因此我们交换后`i`下标对应的元素也还是带扫描的元素，因此`i`不能`i++`  

到了最后，`i`走到`right`位置时就代表扫描结束啦  

```java
class Solution {
    public void sortColors(int[] nums) {
        //分成四个区域
        //left代表全是0的区域的最右侧（包括0）
        //right代表全是2的区域的最左侧（包括2）
        //pos代表扫描数组的指针
        //[0,left]：全是0的区域
        //[left+1,pos-1]：全是1的区域
        //[pos,right-1]：待扫描的元素
        //[right,length-1]：全是2的区域
        int length = nums.length;
        int left = -1;//初始位置在最左侧
        int right = length;//初始位置在最右侧
        int pos = 0;
        while(pos < right){
            if(nums[pos] == 0){
                swap(nums,left+1,pos);
                pos++;
                left++;
            }else if(nums[pos] == 1){
                pos++;
            }else{
                swap(nums,pos,right-1);
                right--;
            }
        }
    }

    private void swap(int [] nums,int left,int right){
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
}
```

## 二、数组排序  
[题目链接](https://leetcode.cn/problems/sort-an-array/description/)  
这一题就是上一题的升级版，我们先说下我们最基础的快排思路  
![image-20250826101349656](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508261013819.png)
但是这样会超时，我们讲讲在此基础上优化的方法  
还是和上一题一样`left`来表示`< key`区域的最右侧（`left`位置元素也是`< key`）  
`right`来表示`> key`区域最左侧（`right`位置元素也是`> key`）  
`i`指针用来扫描数组  

分情况讨论  
1. 若`nums[i] < key`，交换`left+1`和`i`位置的值，`left++`，`i++`  
2. 若`nums[i] == key`，直接`i++`  
3. 若`nums[i] > key`，交换`right-1`和`i`位置的值，`right--`  

此时当前范围内的数组排完序之后，再去递归左右两边的子区间  

为什么这样效率高呢，你想，当数组有序程度高（即`== key`的区域元素多），我们递归的区域的左右区域就变小了  

好，目前有个最大的问题，我们如何选择我们的随机基准值`key`呢？  
根据数学期望值计算，我们选择随机选择一个数，时间复杂度是最接近`O(nlogn)`的  
因此我们要**等概率随机选取当前区间内的一个下标对应的值**，我们使用随机数`Radom`类  
我们这里的`l`和`r`不是左右指针，而是表明**当前子区间的左右两个端点**  
首先我们求出区间长度`r-l+1`，因为我们是递归算法，每个子区间的`r`和`l`都不相同，因此我们要加上偏移量（即区间左端点）`l`使得下标能够在当前子区间内部取值  

```java
class Solution {
    public int[] sortArray(int[] nums) {
        sortPlus(nums,0,nums.length-1);
        return nums;
    }

    private void sortPlus(int [] nums,int l,int r){
        if(l >= r){
            return;
        }
        Random random = new Random();
        //默认一个参数是0~r-l+1，但是加上了偏移量l，使得可以落在对应区间内
        int key = nums[random.nextInt(0,r-l+1)+l];
        //注意左右指针定义
        int left = l-1;
        int right = r+1;
        int pos = l;
        while(pos < right){
            if(nums[pos] < key){
                swap(nums,left+1,pos);
                left++;
                pos++;
            }else if(nums[pos] > key){
                swap(nums,pos,right-1);
                right--;
            }else{
                pos++;
            }
        }
        //数组此时被划分了三个区域，去递归左右两个区域
        sortPlus(nums,l,left);
        sortPlus(nums,right,r);
    }

    private void swap(int [] nums,int left,int right){
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
}
```

## 三、数组中第K个最大元素  
[题目链接](https://leetcode.cn/problems/kth-largest-element-in-an-array/)  
这个之前讲堆排序的时候讲过，这次我们使用快排思想来完成  

像上一题一样，我们是直接递归左右两个子区间的，但是这样难免太慢了，如果有一种方法，能够确定我们要找的k值在左边右边还是中间的哪个区域，就可以高效很多了  
又因为我们要求的是第K个最大元素，因此极有可能落在`> key`值的区域  

因此我们来看图示  
![image-20250826103803931](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508261038054.png)
补充一点：为什么`b+c >= k`就不用去递归右区间了呢  
来到这个条件，就说明条件一`c >= k`不满足，那就说明排除右边的区间，只剩下中间的区间符合要求了  

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        return sortPlus(nums,0,nums.length-1,k);
    }

    private int sortPlus(int [] nums,int l,int r,int k){
        if(l == r){//只有一个元素，肯定是当前元素
            return nums[l];
        }
        Random random = new Random();
        //默认一个参数是0~r-l+1，但是加上了偏移量l，使得可以落在对应区间内
        int key = nums[random.nextInt(r-l+1)+l];
        //注意左右指针定义
        int left = l-1;
        int right = r+1;
        int pos = l;
        while(pos < right){
            if(nums[pos] < key){
                swap(nums,left+1,pos);
                left++;
                pos++;
            }else if(nums[pos] > key){
                swap(nums,pos,right-1);
                right--;
            }else{
                pos++;
            }
        }
        //数组此时被划分了三个区域，看情况去递归哪个区域
        int numMiddle = right-left-1;
        int numRight = r-right+1;

        if(numRight >= k){
            return sortPlus(nums,right,r,k);
        }else if(numMiddle+numRight >=k){
            //找到了直接返回key基准值就好
            return key;
        }else{
            k -= numMiddle+numRight;
            return sortPlus(nums,l,left,k);
        }
    }

    private void swap(int [] nums,int left,int right){
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
}
```

## 四、最小的k个数  
[题目链接](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)  
其实这一题和上一题类似，重复的不再讲，我们来讲数组分完三块之后  
![image-20250826143924804](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202508261439918.png)

1. 如果`a > k`，我们递归左区间即`< key`就好，道理和之前一样  
2. 如果`a + b >= k`，我们就直接返回，为什么？  
因为此时条件1不成立，但是左区间的全部一定都是符合要求的  
比如我此时k值等于4，而左边区间元素个数是`a = 3`，那我此时左边区间的数都符合要求  
我是不是还剩下一个元素没找到，此时就在中间的区间，  
此时不用再递归，直接返回就好  
3. 上述条件都不满足，但是此时我们中间和左边区间是符合要求的  
比如我此时k值等于6，左区间和右区间的值分别为`a = 2  b = 3`  
那我是不是还有一个元素没找到，此时它就在右边的区间  
此时我递归右区间就好，但是就跟上一题一样，我舍去了左中区间，而且左中区间的值都比右区间小  
我刚刚举的例子中，左边和中间的个数和是5，但是我要找最小的6个元素  
那我是不是还剩下一个元素，因此我在右区间找的就是最小的1个元素  
此时就跟我们图示的一样，我们的寻找区域就扩增到了右区域  

```java
class Solution {
    public int[] inventoryManagement(int[] stock, int cnt) {
        inventoryManagementPlus(stock,0,stock.length-1,cnt);
        //此时我们就把最小的k的元素放到了数组的前面
        int [] ret = new int[cnt];
        for(int i = 0;i<cnt;i++){
            ret[i] = stock[i];
        }
        return ret;
    }

    private void inventoryManagementPlus(int [] stock,int l,int r,int cnt){
        int left = l-1;
        int right = r+1;
        int pos = l;
        Random random = new Random();
        int key = stock[random.nextInt(r-l+1)+l];
        while(pos < right){
            if(stock[pos] < key){
                swap(stock,left+1,pos);
                left++;
                pos++;
            }else if(stock[pos] > key){
                swap(stock,right-1,pos);
                right--;
            }else{
                pos++;
            }
        }
        int numleft = left-l+1;
        int numMIddle = right-left-1;
        if(numleft > cnt){
            inventoryManagementPlus(stock,l,left,cnt);
        }else if(numleft+numMIddle >= cnt){
            return;
        }else{
            cnt -= numleft+numMIddle;
            inventoryManagementPlus(stock,right,r,cnt);
        }
    }

    private void swap(int [] stock,int left,int right){
        int temp = stock[left];
        stock[left] = stock[right];
        stock[right] = temp;
    }
}
```

***

<center>希望本篇文章对您有帮助，有错误您可以指出，我们友好交流</center>

***
<center>END</center>