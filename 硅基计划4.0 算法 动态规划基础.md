# 硅基计划4.0 算法 动态规划基础  

***

[toc]

***

# 一、打家劫舍系列（多DP）

## 1. 按摩师（打家劫舍I）  
[题目链接](https://leetcode.cn/problems/the-masseuse-lcci/?envType=problem-list-v2&envId=lbey04Zp)  
这一道题跟打家劫舍I是一样的  
这道题就是让我们选择若干个请求中时间最长的，但是不可以相邻  
根据我们经验，我们选择以`i`位置为结尾来讨论，`dp[i]`表示从前往后选择预约时到了`i`位置的`最长预约时间`  

那么对于这个`i`位置，我们可以`选择/不选择`这个`i`位置的预约  
但是注意，我们如果不选择当前位置预约，前一个位置我们也可以不选，前两个位置也是一样，也就是说`预约不相邻，且中间可以隔着好几个预约`  

我们发现只用一个`dp`表无法表示，因此我们要建立两个`dp`表  

`dp1[i]`表示到了`i`位置选择`i`位置的预约，`dp2[i]`表示我们到了`i`位置**不选择**`i`位置的预约  

因此我们推导状态转移方程，先看`dp1`，它表示我们选择了`i`位置的预约，那我们`i-1`就不可以选正好对应我们的`dp2`，因此`dp1[i] = dp2[i-1]+nums[i-1]`  
我们再来看`dp2`，它代表我们不选择`i`位置预约，还记得我们说过的吗预约之间可以隔着好几个预约，因此对于`i-1`位置预约，我们也是可以`选/不选`  
如果我们选择`i-1`位置的预约，那就是`dp1[i-1]`，如果我们不选`i-1`位置预约，那就是`dp2[i-1]`  
但是我们要的是最大预约时长，因此我们要取最大值，也就是`dp2[i] = Math.max(dp1[i-1],dp2[i-1])`  

我们再来看初始化，我们可以引入虚拟边界，但是要保证填表正确性，我们想想，两个表的`0`位置代表什么意思，就是没有预约，那没有预约我们的最大预约时长是不是`0`  

我们填表的时候需要左边的值，因此我们要从左往右填表，直接返回两个`dp`表最后一个位置的**最大值**  

```java
class Solution {
    public int massage(int[] nums) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        if(nums.length == 1){
            return nums[0];
        }
        int length = nums.length;
        //dp1[i]表示到了i位置时选择当前的预约
        int [] dp1 = new int[length];
        //dp2[i]表示到了i位置时不选择当前预约
        int [] dp2 = new int[length];
        //初始化
        dp1[0] = nums[0];
        //开始填表
        for(int i = 1;i < length;i++){
            //分为两种情况，选择当前i位置预约/不选择当前i位置预约
            //如果选择了当前i位置预约，i-1位置就不可选
            dp1[i] = dp2[i-1]+nums[i];
            //如果不选择当前i位置预约，那我i-1位置预约可以选/也可以不选
            //但是我们要的是最大值
            dp2[i] = Math.max(dp1[i-1],dp2[i-1]);
        }
        //结果去两种情况最大值
        return Math.max(dp1[length-1],dp2[length-1]);
    }
}
```

## 2. 打家劫舍II  
[题目链接](https://leetcode.cn/problems/house-robber-ii/?envType=problem-list-v2&envId=lbey04Zp)  
这一题就是比打家劫舍多了一个条件，也就是数组开头和末尾是相连的  
那我们可不可以转化一下，对于第一个位置，如果我们选择，那是不是`下一个位置和最后一个位置都不能选了`，那我们直接在`[1,length-2]`这个区间内做一次`按摩师（打家劫舍I）`就好了  
如果我们不选择第一个位置，那是不是代表后续的位置都可以选择啊，因此我们直接在`[1,length-1]`区间内做一次`按摩师（打家劫舍I）`就好  

我们直接返回两种情况的`最大值`就好  

```java
class Solution {
    int length;
    public int rob(int[] nums) {
        //这一题就是打家劫舍I的改版
        //分为两种状态
        //1.即如果第一个房子偷了，则下一个房子和最后一个房子不能偷
        //相当于在[2,length-1]区间内做打家劫舍
        //2.如果第一个房子没有被偷，则下一个房子一直到最后一个房子都可以偷
        //相当于在[1,length-1]区间内做打家劫舍
        length = nums.length;
        //分两种情况的打家劫舍
        return Math.max(newRob(nums,1,length-1),newRob(nums,2,length-2)+nums[0]);
    }

    private int newRob(int [] nums,int left,int right){
        if(left > right){
            return 0;
        }
        int [] dp1 = new int[length];
        int [] dp2 = new int[length];
        dp1[left] = nums[left];
        for(int i = left+1;i <= right;i++){
            dp1[i] = dp2[i-1]+nums[i];
            dp2[i] = Math.max(dp1[i-1],dp2[i-1]);
        }
        return Math.max(dp1[right],dp2[right]);
    }
}
```

## 3. 删除获得点数  
[题目链接](https://leetcode.cn/problems/delete-and-earn/description/?envType=problem-list-v2&envId=lbey04Zp)  
其实这一题非常像打家劫舍，因为我们选择了某个数字，左右邻近的数字（不一定就在旁边）就都要被删除  
但是这个数字可能不连续，也就是说如果想像打家劫舍那样，我们就要保证每个状态的数字只能出现一次，比如`[1,1,2,4,4,5,8,8]`，我们选择`2`，那我们就要删除`1`和`4`，但是它们在数组中出现了多次（而不是一次），因此我们可以这样  
我们可以把每个数字出现的次数统计起来，用数组下标表示这一个数，这个下标的值表示这个数`出现的次数`  
这样我们就可以做一次打家劫舍，选择了当前下标数，相邻位置不可以再选  
注意题目中说的是`邻近值`，并不是说的`邻近的元素`  
可以好好体会下  

```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        //这一题就是打乱了房屋顺序的打家劫舍
        //我们可以先预处理原始数组
        int length = 10001;
        int [] arr = new int[length];
        for(int tmp : nums){
            arr[tmp] += tmp;
        }
        int [] dp1 = new int[length];
        int [] dp2 = new int[length];
        dp1[0] = arr[0];
        for(int i = 1;i < length;i++){
            dp1[i] = dp2[i-1]+arr[i];
            dp2[i] = Math.max(dp1[i-1],dp2[i-1]);
        }
        return Math.max(dp1[length-1],dp2[length-1]);
    }
}
```

## 4. 粉刷房子  
[题目链接](https://leetcode.cn/problems/JEj789/?envType=problem-list-v2&envId=lbey04Zp)  
题目中用`0,1,2`三个数字表示三种颜色  
那我们是不是可以这样定义状态表示`dp[i][j]`表示粉刷到`i`房子的时候选择`j`颜色进行粉刷的最小花费  

那我们来研究下状态转移方程，因为题目中说了不用颜色不可以相邻，因此我们就列举其中一种状态转移方程，其他两个类比  
`dp[i][0]`表示我们粉刷`i`房子的时候刷的是`红色`，那么我们前一个房子只能刷`蓝色/绿色`，我们取它们的最小值，再加上刷当前颜色的费用`cost[i][0]`  
因此`dp[i][0] = Math.min(dp[i-1][1],dp[i-1][2])+cost[i][0]`  
`dp[i][1] = Math.min(dp[i-1][0],dp[i-1][2])+cost[i][1]`  
`dp[i][2] = Math.min(dp[i-1][0],dp[i-1][1])+cost[i][2]` 

我们再来看看初始化，我们保证不能越界，引入虚拟边界，那我们`dp[0][...]`表示粉刷第`0`个房子的最小花费，我都没粉刷房子哪来的花费，因此为`0`  
我们每次都是要的上一行的值，因此要从上往下填表  
我们最终返回数组`最后一行的最小值就好`  

```java
class Solution {
    public int minCost(int[][] costs) {
        //我们可以使用一个二维数组去模拟三个dp表
        int length = costs.length;
        //其中dp[i][0]表示从头开始粉刷到第i个房子时使用红色粉刷的最少的钱
        int [][] dp = new int[length+1][3];
        for(int i = 1;i <= length;i++){
            dp[i][0] = Math.min(dp[i-1][1],dp[i-1][2])+costs[i-1][0];
            dp[i][1] = Math.min(dp[i-1][0],dp[i-1][2])+costs[i-1][1];
            dp[i][2] = Math.min(dp[i-1][0],dp[i-1][1])+costs[i-1][2];
        }
        return Math.min(dp[length][0],Math.min(dp[length][1],dp[length][2]));
    }
}
```

# 二、股票系列（多DP）

## 1. 买卖股票的最佳时期含有冷冻期  
[题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/?envType=problem-list-v2&envId=lbey04Zp)  
注意题目中刷的冷冻期，今天卖出后明天无法再购入股票  
那么这样，我们根据经验，我们定义`dp[i][j]`表示第`i`天结束后此时的最大利润，用`j`表示三种状态`0-->买入，1-->可交易（不在冷却期）,2-->冷却期`  
那我们画出状态分析表，具体`分析各个状态的相互关联`  

1. 如果当前第`i`天是买入状态  
> 如果`i-1`天状态还是买入，那我在`i`天啥也不做，也可以保持买入状态  
> 如果`i-1`天状态是冷却期，那我在`i`天就不能是买入状态  
> 如果`i-1`天状态是可交易，那我在`i`天花`price[i]`买入股票就可以进入买入状态  


2. 如果当前第`i`天是冷却期状态  
> 如果`i-1`天状态是冷却期，那我第`i`天不可能还是冷却期（因为只有一天）  
> 如果`i-1`天状态是买入，那我第`i`天可以是冷却期，我只需要卖出`price[i]`股票就好  
> 如果`i-1`天状态是可交易，那我第`i`天不可能是冷却期  

3. 如果当前第`i`天是可交易状态  
> 如果`i-1`天状态是可交易，那我第`i`天啥也不做就好  
> 如果`i-1`天状态是买入，那我第`i`天就不可能是可交易  
> 如果`i-1`天状态是冷却期，那我第`i`天可以转变成可交易状态  

![image-20260120123210817](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/20260120123210907.png)

综上所述，我们的状态转移方程就是  
```java
dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-price[i]);
dp[i][1] = Math.max(dp[i-1][1],dp[i-1][2]);
dp[i][2] = dp[i-1][0]+price[0];
```

我们再来看看初始化部分，特别要注意，因为我们`dp[0][0]`代表的是开始就是`买入状态`，因此`dp[0][0] = -price[0]`，其它默认是`0`  

我们从左往右填表，对于返回值，我们最后一天不能是买入状态（最后一题买入你第二天就卖不出去了），我们返回`卖出和冷却期`的最大值，也就是`Math.max(dp[length-1][1],dp[length-1][2])`

```java
class Solution {
    public int maxProfit(int[] prices) {
        int length = prices.length;
        //0 -> 买入状态，1 -> 可交易状态（手里无股票），2 -> 冷冻期（第二页不能再买入）
        //dp[i][0]表示第i天处于买入状态时候最大利润
        int [][] dp = new int[length][3];
        dp[0][0] = -prices[0];
        for(int i = 1;i < length;i++){
            //此时0状态可能是你前一天买了股票砸了钱，或啥也不干
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);
            //此时可能你前一天是冷冻期，或啥也不干
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][2]);
            //此时2状态表示你前一天卖了股票赚了钱
            dp[i][2] = dp[i-1][0]+prices[i];
        }
        //最后一天如果是买入状态肯定不行，因此dp[length-1][0]不用参与比较
        return Math.max(dp[length-1][1],dp[length-1][2]);
    }
}
```

## 2. 买卖股票的最佳时期含手续费  
[题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/?envType=problem-list-v2&envId=lbey04Zp)  
这一题和上一题并不一样，我们没有冷却期，但是含有手续费  
因此我们可以这样定义状态表示  
`dp1[i]`表示第`i`天结束后，手里还有股票，所获得的最大利润（买入状态）  
`dp2[i]`表示第`i`天结束后，手里没有股票所获得的最大利润（卖出状态）  
注意我们买入和卖出这里算一次手续费，因此我们可以把手续费考虑在卖出的时候  

我们还是来推导状态转移方程  

1. 如果第`i`天处于`买入`状态  
> 第`i-1`天如果是买入，那我第`i`天啥也不干，也还是可以处于买入状态  
> 第`i-1`天如果是卖出，那我第`i`天可以买入股票哦，此时要给`prices[i]`钱  

2. 如果第`i`天处于`卖出`状态  
> 第`i-1`天如果是卖出，那我第`i`天啥也不干，也还是可以处于卖出状态  
> 第`i-1`天如果是买入，那我第`i`天可以把股票卖了，赚取`prices[i]`这么多钱  

两种情况每种情况取得最大值就好  

因此我们的状态转移方程就是  
```java
dp1[i] = Math.max(dp1[i-1],dp2[i-1]-prices[i]);
dp2[i] = Math.max(dp2[i-1],dp1[i-1]+prices[i]-fee);//注意这里要给手续费
```

我们初始化根据我们状态表示来，因此我们`dp2[0]`表示我们刚开始是买入状态，因此`dp2[0] = -prices[0]`  
我们每一次填表都要有前面的状态，因此我们从左往右填表  
并且我们最后一天要保证是卖出状态，因此直接返回`dp2`的最后一个值就好  

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        //这一题和冷冻期股票唯一区别就是卖出时要给手续费
        int length = prices.length;
        //dp1[i]表示到第i天时候的买入状态的利润最大值
        int [] dp1 = new int[length];
        //dp2[i]表示到第i天时候的可交易（卖出）状态的利润最大值
        int [] dp2 = new int[length];
        dp1[0] = -prices[0];
        for(int i = 1;i < length;i++){
            dp1[i] = Math.max(dp1[i-1],dp2[i-1]-prices[i]);
            dp2[i] = Math.max(dp2[i-1],dp1[i-1]+prices[i]-fee);
        }
        //最后一天状态肯定是要卖出的，如果最后一天你还买入那你肯定亏钱
        return dp2[length-1];
    }
}
```

## 3. 买卖股票的最佳时机III  
[题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/?envType=problem-list-v2&envId=lbey04Zp)  
这一题难就难在它最多只限两笔交易，即不能超过两笔（可以是0,1,2）（一次买入卖出整体算一笔）  
因此我们这样定义状态表示  
`dp1[i][j]`表示第`i`天结束后完成了`j`笔交易并且处于`买入`状态的`最大利润`  
`dp2[i][j]`表示第`i`天结束后完成了`j`笔交易并且处于`卖出`状态的`最大利润`  
我们把卖出一次股票定为一次交易（这样好计算）  

好，我们来推导状态转移方程  

1. 如果第`i`天处于买入状态  
> 第`i-1`天如果是买入状态，那我第`i`天啥也不做就好了  
> 第`i-1`天如果是卖出状态，那我第`i`天要把入股票，`-prices[i]`  

2. 如果第`i`天处于卖出状态  
> 第`i-1`天如果是卖出状态，那我第`i`天啥也不做就好了  
> 第`i-1`天如果是买入状态，那我第`i`天要卖出股票，获得`prices[i]`利润，并且交易次数`+1`  

两种情况每种情况取得最大值就好  

因此我们的状态转移方程就是  
```java
dp1[i][j] = Math.max(dp1[i-1][j],dp2[i-1][j]-prices[i]);
dp2[i][j] = Math.max(dp2[i-1][j],dp1[i-1][j-1]+prices[i]);
```

> 注意：我们这里的`j`没有限制次数，其实这是我们后续的题的通用解法  

现在对于`dp2的初始化`，因为我们的交易次数是有限制的，我们可以先让`dp2[i][j] = dp2[i-1][j]`，因为前一天是卖出状态，现在还是卖出状态，交易次数不会增加  
接着我们特判，因为我们`j-1`可能会越界，因此只有在`j-1 >= 0`的时候才会进入最大值比较  
这样是为了更加的合理化，因为交易总不可能是`-1`笔吧  
还有，我们针对两个表的初始化，第一行表示第`0`天  
对于`dp1[0][0]`表示我们开始时候处于买入状态，还没有完成一笔交易，这个时候我们`dp1[0][0]`就是`-prices[0]`，但是我们第一行其他的地方如果不初始化，在我们进行比较的时候，因为我们利润可能是负数，因此最大值比较就会把这些算进去，我们不能让它们参与比较，因此我们设置为`-∞`  
同理对于`dp2[0][0]`表示我们卖出状态，我们还没交易呢哪来的利润，因此是`0`。但是注意，第一行其他位置也要初始化为`-∞`，为了后续取最大值不会干扰判断  

![image-20260120145111241](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/20260120145111442.png)

但是但是，还有一个问题，看到我们状态转移方程了吗，就拿`dp1`来说  
如果我们`dp2[i-1][j]-prices[i]`是`dp2[0][1]-prices[i]`此时是`-∞减去一个数`是不是会溢出，变成一个正无穷的数字了，因此为了避免这种情况，我们要把`-∞`初始化为`0x3f3f3f3f`。用它是因为它足够小/大，并且不会有溢出风险  

因为我们填表都要依赖上一行和左边的值，因此我们是从上往下，从左往右填表。直接返回`dp2`最后一行的最大值就好（最后一天不能是买入状态哦）  

```java
class Solution {
    public int maxProfit(int[] prices) {
        int length = prices.length;
        //创建两个dp表，分别表示买入和卖出状态
        //dp1[i][0]表示第i天结束的时候，交易了0次，且处于买入状态的最大利润
        int [][] dp1 = new int[length][3];
        //dp2[i][0]表示第i天结束的时候，交易了0次，且处于卖出（可交易）状态的最大利润
        int [][] dp2 = new int[length][3];
        //初始化，注意第一行不能初始化为Integer.MIN_VALUE，因为可能在后续做运算的时候溢出
        //因此我们使用0x3f3f3f3f作为最小值
        Arrays.fill(dp1[0],-0x3f3f3f3f);
        dp1[0][0] = -prices[0];
        Arrays.fill(dp2[0],-0x3f3f3f3f);
        dp2[0][0] = 0;
        //开始填表
        for(int i = 1;i < length;i++){
            for(int j = 0;j < 3;j++){
                dp1[i][j] = Math.max(dp1[i-1][j],dp2[i-1][j]-prices[i]);
                //对于dp2要进行判断，因为j-1可能会越界
                dp2[i][j] = dp2[i-1][j];
                if(j-1 >= 0){
                    dp2[i][j] = Math.max(dp2[i][j],dp1[i-1][j-1]+prices[i]);
                }
            }
        }
        //注意对于返回值，可能交易0,1,2....都有可能是最大值，因此要取最后一行最大值
        //同样的道理最后一天你肯定不能处于买入的状态
        int result = Integer.MIN_VALUE;
        for(int tmp : dp2[length-1]){
            result = Math.max(result,tmp);
        }
        return result;
    }
}
```

## 4.  买卖股票的最佳时机IV  
[题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/?envType=problem-list-v2&envId=lbey04Zp)  
这一题和上一题思路一样，但是要注意，如果天数是`10`天（数组长度），但是`k`是`20`，那我们是不是最多只能有`5`笔交易，多出来的`15`次是不是没有作用啊  
因此我们的交易次数`k = Math.min(k,prices.length/2)`  

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        int length = prices.length;
        //注意假设有20天，则20天最多只能进行20/2=10次交易，但此时如果k=30，那我多出来的20是不是就没必要
        k = Math.min(k,length/2);
        //创建两个dp表，分别表示买入和卖出状态
        //dp1[i][0]表示第i天结束的时候，交易了0次，且处于买入状态的最大利润
        int [][] dp1 = new int[length][k+1];
        //dp2[i][0]表示第i天结束的时候，交易了0次，且处于卖出（可交易）状态的最大利润
        int [][] dp2 = new int[length][k+1];
        //初始化，注意第一行不能初始化为Integer.MIN_VALUE，因为可能在后续做运算的时候溢出
        //因此我们使用0x3f3f3f3f作为最小值
        Arrays.fill(dp1[0],-0x3f3f3f3f);
        dp1[0][0] = -prices[0];
        Arrays.fill(dp2[0],-0x3f3f3f3f);
        dp2[0][0] = 0;
        //开始填表
        for(int i = 1;i < length;i++){
            for(int j = 0;j <= k;j++){
                dp1[i][j] = Math.max(dp1[i-1][j],dp2[i-1][j]-prices[i]);
                //对于dp2要进行判断，因为j-1可能会越界
                dp2[i][j] = dp2[i-1][j];
                if(j-1 >= 0){
                    dp2[i][j] = Math.max(dp2[i][j],dp1[i-1][j-1]+prices[i]);
                }
            }
        }
        //注意对于返回值，可能交易0,1,2....都有可能是最大值，因此要取最后一行最大值
        //同样的道理最后一天你肯定不能处于买入的状态
        int result = Integer.MIN_VALUE;
        for(int tmp : dp2[length-1]){
            result = Math.max(result,tmp);
        }
        return result;
    }
}
```

# 三、子数组/子串（连续区间）系列

## 1. 最大子数组和  
[题目链接](https://leetcode.cn/problems/maximum-subarray/?envType=problem-list-v2&envId=lbey04Zp)  
注意子数组区间是连续的，因此根据经验，我们这样定义状态表示  
`dp[i]`表示以`i`位置元素为结尾的`所有的子数组`中的最大和  

那么我们的状态转移方程可以这样推导，对于当前`i`位置  
1. 如果我自己一个元素构成子数组，我的最大和就是`nums[i]`  
2. 如果我和前面（连续）子数组结合，我的最大和就是`nums[i]+dp[i-1]`  

![image-20260120150429128](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/20260120150429323.png)

我们只需要取两者最大值就好  

我们初始化可以这样，引入虚拟节点，但是要考虑和原数组的下标映射关系以及后续填表正确  
我们想，我们求`dp[1]`时要用到`dp[0]`的值，但是我们不能让它干扰我们判断（因为`dp[1]`映射我们原数组`0`下标），我们把`dp[0] = 0`就好  
并且刚刚也看到了，我们`dp`表下标和原数组下标正好错开一位，因此映射到原数组下标要`-1`  

我们每次都是需要的是左边的值，因此是从左向右填表  
但是注意我们求的是子数组最大值，最大值不一定出现在最后一个下标，因此我们要返回的是`整个dp表的最大值`  

```java
class Solution {
    public int maxSubArray(int[] nums) {
        //我们构建dp表
        //其中dp[i]表示以i位置为结尾的所有子数组情况中最大的和
        int length = nums.length;
        int [] dp = new int[length+1];
        //实时跟踪最大值情况
        int ret = Integer.MIN_VALUE;
        for(int i = 1;i <= length;i++){
            dp[i] = Math.max(nums[i-1],dp[i-1]+nums[i-1]);
            ret = Math.max(dp[i],ret);
        }
        //注意要返回的是dp表的最大值，不一定在结尾
        return ret;
    }
}
```

## 2. 环形子数组最大和  
[题目链接](https://leetcode.cn/problems/maximum-sum-circular-subarray/?envType=problem-list-v2&envId=lbey04Zp)  
这一题很像打家劫舍II，数组首位它是相连的，因此我们可以把环形转换为两个一维模型  

![image-20260120151121588](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/20260120151121778.png)

答案在区间内部的好说，就是我们上一题  
但是在区间外部，我们可以这样想，既然我们数组`总和不变`，要想`和最大`，那是不是要使得中间区间的值`尽可能小`，因此我们可以在中间区间求出`最小子数组和`  

因此我们可以这样定义状态表示  
`dp1[i]`表示以`i`位置为结尾的所有子数组中的最大子数组和  
`dp2[i]`表示以`i`位置为结尾的所有子数组中的最小子数组和  

状态转移方程`dp1`就不用多说了，我们重点来看`dp2`  
因为`dp2`表示的是最小子数组和，因此我们方程就是`dp2[i] = Math.min(dp[i-1]+nums[i],nums[i])`  

对于初始化，我们都添加辅助节点，然后两个表`0`下标都是`0`（不用初始化，不会影响后续判断，因为我们原数组所有的数都是正数）  

我们从左往右填表。注意返回值，我们`dp2`求的是最小子数组和，因此我们返回`dp2`值时候要用`原数组所有值和-dp2最小值`，因此返回`Math.max(dp1最大值,sum-dp2最小值)`  

```java
class Solution {
    public int maxSubarraySumCircular(int[] nums) {
        int length = nums.length;
        //统计原数组的和
        int sum = 0;
        //dp1[i]表示以i位置为结尾的最大子数组和
        int [] dp1 = new int[length+1];
        //dp2[i]表示以i位置为结尾的最小子数组和
        int [] dp2 = new int[length+1];
        //跟踪两个表最大值/最小值
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        //开始填表
        for(int i = 1;i <= length;i++){
            dp1[i] = Math.max(dp1[i-1]+nums[i-1],nums[i-1]);
            max = Math.max(max,dp1[i]);
            dp2[i] = Math.min(dp2[i-1]+nums[i-1],nums[i-1]);
            min = Math.min(min,dp2[i]);
            sum += nums[i-1];
        }
        //注意返回结果，如果数组全部是负数，这会导致sum和dp2中最小值相等
        //导致sum-dp2Min影响最终结果判断
        return sum == min ? max : Math.max(max,sum-min);
    }
}
```

## 3. 乘积最大子数组  
[题目链接](https://leetcode.cn/problems/maximum-product-subarray/?envType=problem-list-v2&envId=lbey04Zp)  
根据经验，我们这样定义状态表示  
`dp[i]`表示以`i`位置为结尾的所有子数组中`最大乘积`  

因此，对于`i`位置数字，我们可以自己一个结合，也可以和前面的子数组结合  
针对和前面子数组结合的情况，我们要注意，如果我们`dp[i-1]*nums[i]`里面的值如果是`一负一正`，这样会使我们的数值越来越小，不满足我们的状态表示，这个时候我们要想获得最大乘积，就要保证`nums[i]`是正的，但是题目中说了数字有正有负  
因此我们要定义两个`dp`表  

`dp1[i]`表示以`i`位置为结尾的所有子数组中`最大乘积`（里面存的是正数）  
`dp2[i]`表示以`i`位置为结尾的所有子数组中`最小乘积`（里面存的可能是是负数，也可能是正数，但是总之是所有情况中的最小值）  

因此如果要和前面子数组结合，我们看  
1. 如果`nums[i] > 0`，则`dp1[i] = dp1[i-1]*nums[i] dp2[i] = dp2[i-1]*nums[i]`，取两者最大值  
2. 如果`nums[i] < 0`，则`dp1[i] = dp2[i-1]*nums[i] dp1[i] = dp2[i-1]*nums[i]`，取两者最小值  

对于初始化，我们要使用虚拟节点，除了要保证求最大值和最小值不影响外，还要保证相乘后不能为`0`，因此`dp1[0] = dp2[0] = 1`  
我们从左往右填表，然后返回`dp1`最大值就好  

```java
class Solution {
    public int maxProduct(int[] nums) {
        int length = nums.length;
        //dp1[i]表示以i位置为结尾的所有子数组中的最大乘积
        int [] dp1 = new int[length+1];
        //dp2[i]表示以i位置为结尾的所有子数组中的最小乘积
        int [] dp2 = new int[length+1];
        //跟踪最大值
        int ret = Integer.MIN_VALUE;
        //初始化
        dp1[0] = dp2[0] = 1;
        //填表
        for(int i = 1;i <= length;i++){
            //注意nums[i]可能是正的也可能是负的
            dp1[i] = Math.max(Math.max(nums[i-1],dp1[i-1]*nums[i-1]),dp2[i-1]*nums[i-1]);
            ret = Math.max(ret,dp1[i]);
            dp2[i] = Math.min(Math.min(nums[i-1],dp2[i-1]*nums[i-1]),dp1[i-1]*nums[i-1]);
        }
        return ret;
    }
}
```

## 4. 乘积为正数的最长子数组  
[题目链接](https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/?envType=problem-list-v2&envId=lbey04Zp)  
这一题按照我们的经验，状态表示定义。`dp[i]`代表以`i`位置为结尾的所有的子数组中，乘积为`正数`的最长子数组`长度`  

好，我们来分析状态转移方程  
1. 如果只考虑当前元素，不和前面子数组结合。如果`nums[i] > 0`则`dp[i] = 1`，否则就是`0`  
2. 如果当前元素考虑和前面的子数组结合。如果`nums[i] > 0`正好就是`dp[i-1]`+1；但如果是`nums[i] < 0`，那我们要使得乘积是正数，是不是要去找负数区间啊，但是我们只定义了正数的区间  

因此综合上述情况，我们要定义两个`dp`表  
`dp1`表示乘积为正数的子数组长度，`dp2`表示乘积为负数的子数组长度  

因此当`nums[i] < 0`时，自然就是`dp1[i] = dp2[i-1]+1`.......吗？  
其实是错误的，如果`dp2[i-1] = 0`，代表前面的乘积都是正数，无法凑出负数的积，因此我们还要特判`如果dp2[i-1] = 0`，我们`dp1[i] = 0`，否则才是`dp2[i-1]+1`  

同理当`nums[i] > 0`时，自然就是`dp2[i] = dp2[i-1]+1`.........吗？  
其实还是不对，如果`dp2[i-1] = 0`代表前面的乘积都是正数  

综合上述，我们的状态转移方程就是  
```java
if(nums[i] > 0){
	dp1[i] = dp1[i-1]+1;
	dp2[i] = dp2[i-1] == 0 ? 0 : dp2[i-1]+1;
}
if(nums[i] < 0){
	dp1[i] = dp2[i-1] == 0 ? 0 : dp2[i-1]+1;
	dp2[i] = dp1[i-1]+1;
}
```

好，我们再来看初始化，我们预留一个位置防止填表越界  
我们从左往右填表，并且最后返回整个`dp1`表的最大值  

```java
class Solution {
    public int getMaxLen(int[] nums) {
        int length = nums.length;
        //dp1[i]表示以i位置为结尾的所有子数组的乘积为正的最大长度
        int [] dp1 = new int[length+1];
        //dp2[i]表示以i位置为结尾的所有子数组的乘积为负的最大长度
        int [] dp2 = new int[length+1];
        //跟踪最大长度值
        int ret = Integer.MIN_VALUE;
        //填表
        for(int i = 1;i <= length;i++){
            //分情况讨论，并且注意细节问题
            if(nums[i-1] > 0){
                dp1[i] = dp1[i-1]+1;
                //如果我前面的子数组区间乘积都是正的，乘当前正数，还是正数，不满足dp2[i]的含义
                dp2[i] = dp2[i-1] == 0 ? 0 : dp2[i-1]+1;
            }
            if(nums[i-1] < 0){
                //如果我前面的子数组区间乘积都是正的，那么乘上当前负数，就变成负的了
                dp1[i] = dp2[i-1] == 0 ? 0 : dp2[i-1]+1;
                dp2[i] = dp1[i-1]+1;
            }
            ret = Math.max(ret,dp1[i]);
        }
        return ret;
    }
}
```

## 5. 等差数列划分  
[题目链接](https://leetcode.cn/problems/arithmetic-slices/?envType=problem-list-v2&envId=lbey04Zp)  
注意我们等差数列的这个子数组内`至少要3个元素并且是连续的`  
借此，我们定义`dp[i]`表示以`i`位置为结尾的所有子数组中`有多少个`等差数列  

因此，我们借助一个性质，如果`[a,b,c,d]`已经是一个等差数列，并且`[c,d,e]`也构成等差数列，那么`[a,b,c,d,e]`也构成等差数列，因为两个数列中都出现了`c,d`，代表它们`公差`相同  
因此，如果`i`位置要构成等差数列，那要和`i-1`和`i-2`位置的数先构成等差数列  
因此如果`nums[i] - nums[i-1] = nums[i-1] - nums[i-2]`，此时就可以构成等差数列，那我们再去看看`i-1`，`i-2`，`i-3`能否构成等差数列  
在它们基础上，加上`nums[i]`这个数就好，此时`nums[i-1],nums[i-2]`相当于以`nums[i-1]`结尾能否构成等差数列，正好就是`dp[i-1]`  
但是还有一种特殊情况，就是单独`nums[i] nums[i-1] nums[i-2]`三个数构成等差数列，因为我们`dp`存的是`所有子数组`，因此这种情况没考虑到，最后`dp[i]`要`+1`  
但是，如果我们`nums[i] nums[i-1] nums[i-2]`三个数不能构成等差数列，无论和前面多少个数结合都不可能构成等差数列，因此就是`0`  

综上所述，我们的状态转移方程就是`dp[i] = nums[i] - nums[i-1] == nums[i-1] - nums[i-2] ? dp[i-1]+1 : 0`  

我们初始化要从原数组`2`下标开始填表，因此我们不用多加一个节点  
从左往右填表就好，我们要返回`dp`表的和，因为我们求的是有多少种划分方法  

```java
class Solution {
    public int numberOfArithmeticSlices(int[] nums) {
        int length = nums.length;
        if(length < 2){
            return 0;
        }
        //dp[i]表示以i位置为结尾的所有子数组中有多少个是等差数列
        int [] dp = new int[length];
        //初始化，因为至少要三个元素，因此第一个位置和第二个位置是0
        dp[0] = dp[1] = 0;
        //跟踪结果
        int ret = 0;
        //填表
        for(int i = 2;i < length;i++){
            int d1 = nums[i]-nums[i-1];
            int d2 = nums[i-1]-nums[i-2];
            dp[i] = d1 == d2 ? dp[i-1]+1 : 0;
            ret += dp[i]; 
        }
        return ret;
    }
}
```

## 6. 最长湍流子数组  
[题目链接](https://leetcode.cn/problems/longest-turbulent-subarray/?envType=problem-list-v2&envId=lbey04Zp)  
这一题要求我们相邻元素必须是`一升一降`关系，不能一直上升，也不能一直下降，要呈现一个波浪型  
我们根据经验，定义`dp[i]`表示以`i`位置为结尾的子数组中`最长`的湍流子数组`长度`  
但是我们在推导方程的时候就发现，如果我们只有一个`dp`表，就算我们知道`nums[i-1]`和`nums[i]`的大小关系，我们找的是湍流子数组，那就要找`i-1`之前的呈现上升/下降趋势的数组  
因此我们这样定义状态表示，`dp1[i]`表示以`i`位置元素为结尾的所有子数组中`最后呈现上升趋势`的最长湍流子数组`长度`，`dp2[i]`表示以`i`位置元素为结尾的所有子数组中`最后呈现下降趋势`的最长湍流子数组`长度`  

这样，我们来推到方程  
首先是`dp1`  
如果`nums[i-1] > nums[i]`此时是下降趋势，但是我们`dp1`表示的是上升趋势，因此我们此时`自己一个元素`成一个子数组，长度就是`1`  
如果`nums[i-1] < nums[i]`此时是上升趋势，符合我们状态表示，那我们只需要让`nums[i-1]`和`nums[i-2]`呈现下降趋势就好，正好就是`dp2[i-1]`，再加上当前位置元素`+1`  
如果`nums[i-1] == nums[i]`，此时如果想呈现上升趋势，依旧是自己一个元素，因此是`1`  

再来看`dp2`  
如果是`nums[i-1] > nums[i]`此时是下降趋势，符合我们的状态表示，那我们只需要让`nums[i-1]`和`nums[i-2]`呈现上升趋势就好，正好就是`dp1[i-1]`，再加上当前位置元素`+1`  
如果是`nums[i-1] < nums[i]`，此时是上升趋势，但是我们`dp2`表示的是下降趋势，因此我们只选当前元素，长度就是`1`  
如果`nums[i-1] == nums[i]`，此时如果想呈现下降趋势，依旧是自己一个元素，因此是`1`  

我们再来看看初始化，我们要把所有位置都初始化为`1`，因为每一个元素都可以自己组成湍流子数组，这种初始化叫做`最坏情况`初始化  
我们从左往右填表，最后返回两个表最大值  

```java
class Solution {
    public int maxTurbulenceSize(int[] arr) {
        int length = arr.length;
        if(length <= 1){
            return 1;
        }
        //dp1[i]表示以i位置为结尾的呈现上升趋势的最长湍流子数组长度
        int [] dp1 = new int[length];
        //dp2[i]表示以i位置为结尾的呈现下降趋势的最长湍流子数组长度
        int [] dp2 = new int[length];
        //跟踪两种情况的最长湍流数组长度
        int ret = 0;
        //初始化
        dp1[0] = dp2[0] = 1;
        //填表
        for(int i = 1;i < length;i++){
            dp1[i] = arr[i-1] < arr[i] ? dp2[i-1]+1 : 1;
            dp2[i] = arr[i-1] > arr[i] ? dp1[i-1]+1 : 1;
            ret = Math.max(Math.max(dp1[i],dp2[i]),ret);
        }
        return ret;
    }
}
```

## 7. 单词划分  
[题目链接](https://leetcode.cn/problems/word-break/?envType=problem-list-v2&envId=lbey04Zp)  
这一题根据经验，`dp[i]`表示`0~i`区间内的字符串能否被`字典`中的单词拼接而成，能就是`true`，不能就是`false`  
因此我们方程推导就是，确定`i`位置以前的字符串能拼接，并且`i`位置字符在字典中，就说明当前字符串可以拼接  

![image-20260120200657908](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/20260120200658050.png)

如果`dp[j-1] == true`，并且`[j,i]`区间内的子串（连续）在字典中存在，我们`dp[i]`就是`true`，否则就是`false`。我们找到一种可能的拼接方案后就可以让`i`往后走去判断下一个位置字符了  

注意初始化，我们`j-1`可能会越界，因此我们可以添加辅助节点，为了后续填表正确，我们`dp[0] = true`  
因为添加了辅助节点，因此我们和字符串下标的映射相差`1`，这样非常不好对应  
因此针对字符串的问题，我们可以在字符前面添加一个`" "`的字符，这样我们字符下标就可以和`dp`表下标对齐了  

我们从左往右填表，并且返回`dp`表最后一个位置的值  

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        HashSet<String> hash = new HashSet<>();
        for(String str : wordDict){
            hash.add(str);
        }
        int length = s.length();
        //处理原字符串，使其下标对应dp表下标
        s = " "+s;
        //dp[i]表示以i位置为结尾的字符串能否被拼接
        boolean [] dp = new boolean[length+1];
        //默认是false，但是为了不影响后续判断，第一个位置初始化为true
        dp[0] = true;
        //填表
        for(int i = 1;i <= length;i++){
            //从i位置开始向前枚举，查看从0到j的子串是否能被拼接
            //最后再查看从j到i子串能否被拼接，注意有效字符的起始下标是1
            for(int j = i;j >= 1;j--){
                //查看dp表以及字典
                if(dp[j-1] && hash.contains(s.substring(j,i+1))){
                    //如果存在，则更新表
                    dp[i] = true;
                    //此时直接跳出循环就好，因为我们只需要找一种可拼接方式
                    break;
                }
            }
        }
        return dp[length];
    }
}
```

## 8. 环绕字符串中唯一子字符串  
[题目链接](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/?envType=problem-list-v2&envId=lbey04Zp)  
这一题就是说，给我们一个字符串比如`[c,a,c]`，判断他所有的子串`[c],[c,a],[c,a,c],[a],[a,c],[c]`，判断这些子串在`base`串中是否出现  

因此我们这样定义状态表示  
`dp[i]`表示以`i`位置字符为结尾的`所有子串`中有`多少个`在`base`中出现  

我们推导方程可以分成自己一个字符，和前面字符结合的两种情况  
1. 自己一个字符。因为我们都是`26`个字母，肯定在`base`出现，因此是`1`  
2. 和前面字符结合。我们先找到以`i-1`位置为结尾的有多少个在`base`中出现再结合当前字符，那我们就可以判断`前面一个字符ASCII+1是否等于当前字符ASCII（要保证连续）`或者是`前面字符是z当前字符是a`，两种只需要有一种满足就好，因此是`dp[i-1]`。注意此时不能`+1`，因为我们求的是种类不是长度  

我们要保证填表不越界，并且每一个字符自己单独一个，肯定在`base`中出现，因此都初始化为`1`，这样我们就无需再特判长度为`1`的情况，简化代码  
我们保证从左往右填表就好  

但是对于返回值，要去重，为什么？  
当` s = "abca"` 时  
```
i=0（字符 a）：dp[0]=1 → 子串 a
i=1（字符 b）：dp[1]=2 → 子串 b、ab
i=2（字符 c）：dp[2]=3 → 子串 c、bc、abc
i=3（字符 a）：dp[3]=1 → 子串 a
```
如果直接求和 1+2+3+1=7，但实际唯一子串只有 `a、b、ab、c、bc、abc` 共 6 个  
问题出在 a 被重复统计了两次（i=0 和 i=3 的 a 子串是同一个）  
同一个字符结尾的重复子串，只保留最长的那一组（因为最长的已经包含了所有更短的）  
相当于 “短的重复子串被长的覆盖了”，自然就去重了  

```java
class Solution {
    public int findSubstringInWraproundString(String s) {
        char [] ss = s.toCharArray();
        int length = ss.length;
        //dp[i]表示以i位置为结尾的所有子串中有多少个在base中出现
        int [] dp = new int[length];
        //初始化，因为我们字符串每一个都是小写字符，因此肯定都会出现一次
        Arrays.fill(dp,1);
        //填表
        for(int i = 1;i < length;i++){
            if((ss[i-1]+1 == ss[i]) || (ss[i] == 'a' && ss[i-1] == 'z')){
                dp[i] += dp[i-1];
            }
        }
        //去重操作
        int [] dp1 = new int[26];
        for(int i = 0;i < length;i++){
            dp1[ss[i]-'a'] = Math.max(dp1[ss[i]-'a'],dp[i]);
        }
        int ret = 0;
        //求和
        for(int couunt : dp1){
            ret += couunt;
        }
        return ret;
    }
}
```

***

<center>感谢你的阅读</center>

***

<center>END</center>