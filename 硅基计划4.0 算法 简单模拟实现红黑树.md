# 硅基计划4.0 算法 简单模拟实现红黑树

## 1. 删除节点的四种情况示意图  

![image-20260204214822624](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/20260204214822747.png)

![image-20260204214833065](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/20260204214833149.png)

![image-20260204214844901](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/20260204214844996.png)

![image-20260204214855641](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/20260204214855745.png)

## 2. 代码部分  

```java
public enum Color {
    BLACK,RED;
}

```

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;

/**
 * @author pluchon
 * @create 2026-02-04-14:06
 * 作者代码水平一般，难免难看，请见谅
 */
public class RBTree {
    static class RBTreeNode {
        public RBTreeNode left;
        public RBTreeNode right;
        public RBTreeNode parent;
        public int val;
        public Color color = Color.RED;

        public RBTreeNode(int val) {
            this.val = val;
        }
    }

    public static RBTreeNode root;

    //插入
    public boolean insert(int value){
        //1. 首先按照正常的二叉搜索树插入节点
        RBTreeNode node = new RBTreeNode(value);
        //首先判断根节点是不是空
        if(root == null){
            root = node;
            root.color = Color.BLACK;
            return true;
        }
        //如果根节点不是空，则要找到插入位置
        RBTreeNode parent = null;
        RBTreeNode current = root;
        while(current != null) {
            if (current.val < value) {
                parent = current;
                current = current.right;
            } else if (current.val > value) {
                parent = current;
                current = current.left;
            } else {
                return false;
            }
        }

        if(parent.val > value){
            parent.left = node;
        }else{
            parent.right = node;
        }
        node.parent = parent;

        //重新让current指向新插入的节点，用于后续平衡调整
        current = node;

        //2. 此时进行调整
        while(parent != null && parent.color == Color.RED){
            RBTreeNode grandParent = parent.parent;
            if(grandParent == null) break; // 安全检查

            if(grandParent.left == parent){
                RBTreeNode parentBrother = grandParent.right;
                if(parentBrother != null && parentBrother.color == Color.RED){
                    parent.color = Color.BLACK;
                    parentBrother.color = Color.BLACK;
                    grandParent.color = Color.RED;
                    current = grandParent;
                    parent = current.parent;
                }else{
                    if(parent.right == current){
                        rotateLeft(parent);
                        //交换指针，确保下一步单旋时逻辑正确
                        RBTreeNode temp = parent;
                        parent = current;
                        current = temp;
                    }
                    rotateRight(grandParent);
                    parent.color = Color.BLACK;
                    grandParent.color = Color.RED;
                }
            }else{
                RBTreeNode parentBrother = grandParent.left;
                if(parentBrother != null && parentBrother.color == Color.RED){
                    parent.color = Color.BLACK;
                    parentBrother.color = Color.BLACK;
                    grandParent.color = Color.RED;
                    current = grandParent;
                    parent = current.parent;
                }else{
                    if(parent.left == current){
                        rotateRight(parent);
                        RBTreeNode temp = parent;
                        parent = current;
                        current = temp;
                    }
                    rotateLeft(grandParent);
                    parent.color = Color.BLACK;
                    grandParent.color = Color.RED;
                }
            }
        }
        root.color = Color.BLACK;
        return true;
    }

    //删除
    public boolean remove(int val){ // 去掉 static 方便管理 root
        //寻找要删除的节点
        RBTreeNode parent = null;
        RBTreeNode current = root;
        while(current != null){
            if(current.val < val){
                parent = current;
                current = current.right;
            }else if(current.val > val){
                parent = current;
                current = current.left;
            }else{
                //此时找到了我们要删除的节点，执行删除逻辑
                removeNode(parent,current);
                //删除成功
                return true;
            }
        }
        //删除失败
        return false;
    }

    //二叉搜索树的删除逻辑
    public static void removeNode(RBTreeNode parent, RBTreeNode current) {
        //记录真正被物理删除的节点的颜色
        Color removedColor;
        //updatePos应该是“接替者”，updateParent 是接替者的父节点
        RBTreeNode updatePos;
        RBTreeNode updateParent;

        if (current.left == null) {
            //情况A: 左为空，右孩子顶上去
            removedColor = current.color;
            updatePos = current.right;
            //顶替者是右孩子
            updateParent = parent;

            if (current == root) {
                root = updatePos;
                if (root != null) root.parent = null;
            } else if (current == parent.left) {
                parent.left = updatePos;
                if (updatePos != null) updatePos.parent = parent;
            } else {
                parent.right = updatePos;
                if (updatePos != null) updatePos.parent = parent;
            }
        } else if (current.right == null) {
            //情况B: 右为空，左孩子顶上去
            removedColor = current.color;
            updatePos = current.left;
            //顶替者是左孩子
            updateParent = parent;

            if (current == root) {
                root = updatePos;
                if (root != null) root.parent = null;
            } else if (current == parent.left) {
                parent.left = updatePos;
                if (updatePos != null) updatePos.parent = parent;
            } else {
                parent.right = updatePos;
                if (updatePos != null) updatePos.parent = parent;
            }
        } else {
            //情况C: 都不为空，找左子树最大值 (前驱)
            RBTreeNode leftMax = current.left;
            RBTreeNode leftMaxParent = current;
            while (leftMax.right != null) {
                leftMaxParent = leftMax;
                leftMax = leftMax.right;
            }

            //把leftMax的值给current，改为删除leftMax节点
            current.val = leftMax.val;
            //真正消失在树里的颜色是leftMax的
            removedColor = leftMax.color;
            //leftMax是最大值，只可能有左孩子
            updatePos = leftMax.left;
            updateParent = leftMaxParent;

            //物理删除leftMax
            if (leftMaxParent.left == leftMax) {
                leftMaxParent.left = updatePos;
            } else {
                leftMaxParent.right = updatePos;
            }
            if (updatePos != null) updatePos.parent = leftMaxParent;
        }

        //只有删除黑色节点，才需要通过AdjustColor补齐那一层黑色
        if (removedColor == Color.BLACK) {
            AdjustColor(updatePos, updateParent);
        }
    }

    //调整颜色
    public static void AdjustColor(RBTreeNode node, RBTreeNode parent) {
        //如果node是红色，直接染黑就补全了缺失的黑色，循环结束
        // 如果node到达根节点，黑色少一层也无妨，循环结束
        while (node != root && (node == null || node.color == Color.BLACK)) {
            if (node == parent.left) {
                RBTreeNode brother = parent.right;
                //1.兄弟是红色
                if (brother != null && brother.color == Color.RED) {
                    brother.color = Color.BLACK;
                    parent.color = Color.RED;
                    rotateLeft(parent);
                    brother = parent.right; // 刷新兄弟节点
                }
                //2. 兄弟的两个孩子都是黑色 (包含 null)
                if ((brother.left == null || brother.left.color == Color.BLACK) &&
                        (brother.right == null || brother.right.color == Color.BLACK)) {
                    brother.color = Color.RED;
                    node = parent; // 向上冒泡
                    parent = (node != null) ? node.parent : null;
                } else {
                    //3.兄弟右孩子是黑色，左孩子是红色
                    if (brother.right == null || brother.right.color == Color.BLACK) {
                        if (brother.left != null) brother.left.color = Color.BLACK;
                        brother.color = Color.RED;
                        rotateRight(brother);
                        brother = parent.right; // 刷新兄弟
                    }
                    //4.兄弟右孩子是红色
                    brother.color = parent.color;
                    parent.color = Color.BLACK;
                    if (brother.right != null) brother.right.color = Color.BLACK;
                    rotateLeft(parent);
                    node = root; // 强制结束
                }
            } else {
                // 镜像对称：node 是右孩子
                RBTreeNode brother = parent.left;
                if (brother != null && brother.color == Color.RED) {
                    brother.color = Color.BLACK;
                    parent.color = Color.RED;
                    rotateRight(parent);
                    brother = parent.left;
                }
                if ((brother.right == null || brother.right.color == Color.BLACK) &&
                        (brother.left == null || brother.left.color == Color.BLACK)) {
                    brother.color = Color.RED;
                    node = parent;
                    parent = (node != null) ? node.parent : null;
                } else {
                    if (brother.left == null || brother.left.color == Color.BLACK) {
                        if (brother.right != null) brother.right.color = Color.BLACK;
                        brother.color = Color.RED;
                        rotateLeft(brother);
                        brother = parent.left;
                    }
                    brother.color = parent.color;
                    parent.color = Color.BLACK;
                    if (brother.left != null) brother.left.color = Color.BLACK;
                    rotateRight(parent);
                    node = root;
                }
            }
        }
        //不管是因为问题上移遇到了红节点，还是接替者本身就是红节点，只要我能把你染黑，我就能平掉那笔‘黑债’
        //如果实在没红节点可染，最后把根节点染黑也是符合性质要求的
        if (node != null) node.color = Color.BLACK;
    }

    //验证部分
    public boolean isValidRBTree(){
        if(root == null) return true;
        if(root.color != Color.BLACK) return false;

        int expectedBlackCount = 0;
        RBTreeNode current = root;
        while(current != null){
            if(current.color == Color.BLACK) expectedBlackCount++;
            current = current.left;
        }
        // 具体校验逻辑
        return checkStructure(root, 0, expectedBlackCount);
    }

    //参数逻辑：pathBlackNodeCount是累加值，expectedBlackCount是目标值
    public static boolean checkStructure(RBTreeNode root, int pathBlackNodeCount, int expectedBlackCount){
        if(root == null){
            return pathBlackNodeCount == expectedBlackCount;
        }
        RBTreeNode parent = root.parent;
        if(parent != null && parent.color == Color.RED && root.color == Color.RED){
            return false;
        }
        if(root.color == Color.BLACK){
            pathBlackNodeCount++; //这里累加当前路径的黑节点
        }
        //同事城楼才返回
        return checkStructure(root.left, pathBlackNodeCount, expectedBlackCount)
                && checkStructure(root.right, pathBlackNodeCount, expectedBlackCount);
    }

    //右单旋
    public static void rotateRight(RBTreeNode parent){
        RBTreeNode subL = parent.left;
        RBTreeNode subLR = subL.right;
        parent.left = subLR;
        if(subLR != null){
            subLR.parent = parent;
        }
        subL.right = parent;
        RBTreeNode grandParent = parent.parent;
        parent.parent = subL;
        if(parent == root){
            root = subL;
            subL.parent = null;
        }else{
            if(grandParent.right == parent) grandParent.right = subL;
            else grandParent.left = subL;
            subL.parent = grandParent;
        }
    }

    //左单旋
    public static void rotateLeft(RBTreeNode parent){
        RBTreeNode subR = parent.right;
        RBTreeNode subRL = subR.left;
        parent.right = subRL;
        if(subRL != null){
            subRL.parent = parent;
        }
        RBTreeNode grandParent = parent.parent;
        subR.left = parent;
        parent.parent = subR;
        if(parent == root){
            root = subR;
            root.parent = null;
        }else{
            if(grandParent.right == parent) grandParent.right = subR;
            else grandParent.left = subR;
            subR.parent = grandParent;
        }
    }

    //中序遍历
    public static void inorder(RBTreeNode root){
        if(root == null) return;
        inorder(root.left);
        System.out.print(root.val + " ");
        inorder(root.right);
    }

    // 辅助方法：计算高度
    public static int getTreeHeight(RBTreeNode node) {
        if (node == null) return 0;
        return Math.max(getTreeHeight(node.left), getTreeHeight(node.right)) + 1;
    }

    public static void main(String[] args) {
        RBTree tree = new RBTree();
        System.out.println("--- 基础测试：1-10 顺序插入 ---");
        for (int i = 1; i <= 10; i++) tree.insert(i);
        System.out.println("合法性验证: " + tree.isValidRBTree());
        System.out.print("中序遍历结果: ");
        inorder(RBTree.root);
        System.out.println();

        System.out.println("\n--- 极端测试：大数据量压测 (10万) ---");
        RBTree bigTree = new RBTree();
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < 100000; i++) list.add(i);
        Collections.shuffle(list);
        long start = System.currentTimeMillis();
        for (int v : list) bigTree.insert(v);
        long end = System.currentTimeMillis();
        System.out.println("耗时: " + (end - start) + "ms");
        System.out.println("合法性验证: " + bigTree.isValidRBTree());

        // --- 补充测试 1：顺序删除测试 ---
        System.out.println("--- 补充测试 1：顺序删除测试 ---");
        for (int i = 1; i <= 100; i++) tree.insert(i);
        boolean isOk = true;
        for (int i = 1; i <= 100; i++) {
            tree.remove(i);
            if (!tree.isValidRBTree()) {
                System.out.println("删除 " + i + " 后，红黑树失效！");
                isOk = false;
                break;
            }
        }
        System.out.println("顺序删除验证结果: " + (isOk ? "PASS" : "FAIL"));

        System.out.println("\n--- 补充测试 2：混合随机压测 ---");
        RBTree mixTree = new RBTree();
        Random random = new Random();
        List<Integer> activeNodes = new ArrayList<>();

        //随机插入 10000 个
        for (int i = 0; i < 10000; i++) {
            int val = random.nextInt(100000);
            if (mixTree.insert(val)) {
                activeNodes.add(val);
            }
        }
        System.out.println("成功插入节点数: " + activeNodes.size());

        Collections.shuffle(activeNodes);

        //删除数量不能超过 activeNodes 的实际大小
        int deleteTarget = Math.min(activeNodes.size(), 5000);
        int deleteCount = 0;
        for (int i = 0; i < deleteTarget; i++) {
            int toRemove = activeNodes.get(i);
            if (mixTree.remove(toRemove)) {
                deleteCount++;
                if (!mixTree.isValidRBTree()) {
                    System.out.println("随机删除出错！值: " + toRemove);
                    isOk = false;
                    break;
                }
            }
        }
        System.out.println("成功随机删除节点数: " + deleteCount + "，合法性验证: " + mixTree.isValidRBTree());

        System.out.println("\n--- 补充测试 3：性能高度测试 ---");
        // 插入 10 万个随机数，查看高度
        RBTree perfTree = new RBTree();
        for (int i = 0; i < 100000; i++) {
            perfTree.insert(random.nextInt(1000000));
        }
        int height = getTreeHeight(perfTree.root);
        System.out.println("10万节点红黑树高度: " + height);
        System.out.println("理论最大高度约为: " + (2 * (Math.log(100000) / Math.log(2))));
    }
}
```


***

<center>感谢你的阅读</center>